   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	botherAddress.constprop.8:
  13               	.LFB80:
  14               		.file 1 "TakkI2C.c"
   1:TakkI2C.c     **** // (C) 2012 Biorobotics Lab and Nonolith Labs
   2:TakkI2C.c     **** // (C) 2011, 2012 Ian Daniher (Nonolith Labs) <ian@nonolithlabs.com>
   3:TakkI2C.c     **** // (C) 2012 Kevin Mehall (Nonolith Labs) <kevin@nonolithlabs.com>
   4:TakkI2C.c     **** // Licensed under the terms of the GNU GPLv3+
   5:TakkI2C.c     **** 
   6:TakkI2C.c     **** #include "TakkTile.h"
   7:TakkI2C.c     **** 
   8:TakkI2C.c     **** inline uint8_t calcTinyAddr(uint8_t row, uint8_t column) { return (((row)&0x0F) << 4 | (column&0x07
   9:TakkI2C.c     **** inline uint8_t calcTinyAddrFlat(uint8_t cell) { return (((cell/5)&0x0F) << 4 | ((cell%5)&0x07) << 1
  10:TakkI2C.c     **** 
  11:TakkI2C.c     **** uint8_t botherAddress(uint8_t address, bool stop){
  15               		.loc 1 11 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  12:TakkI2C.c     **** 	// Function to write address byte to I2C, returns 1 if ACK, 0 if NACK.
  13:TakkI2C.c     **** 	// 'stop' specifies an optional stop bit on the transaction.
  14:TakkI2C.c     **** 	// NB: Don't read from a non-existant address or the CPU will hang waiting for ACK
  15:TakkI2C.c     **** 
  16:TakkI2C.c     **** 	// quick command mode - RIF/WIF trips on ACK
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
  22               		.loc 1 17 0
  23 0000 9091 8204 		lds r25,1154
  24 0004 9260      		ori r25,lo8(2)
  25 0006 9093 8204 		sts 1154,r25
  18:TakkI2C.c     **** 	// set address to bother
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
  26               		.loc 1 19 0
  27 000a 8093 8604 		sts 1158,r24
  20:TakkI2C.c     **** 	// if address ends in one, wait for a read to finish
  21:TakkI2C.c     **** 	if (address & 1) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
  28               		.loc 1 21 0
  29 000e 80FF      		sbrs r24,0
  30 0010 00C0      		rjmp .L10
  31               	.LVL1:
  32               	.L9:
  33 0012 8091 8404 		lds r24,1156
  34 0016 87FF      		sbrs r24,7
  35 0018 00C0      		rjmp .L9
  36               	.L4:
  22:TakkI2C.c     **** 	// if address ends in zero, wait for a write to finish
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
  24:TakkI2C.c     **** 	// initiate stop condition if (stop)
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
  37               		.loc 1 25 0
  38 001a 8091 8304 		lds r24,1155
  39 001e 8360      		ori r24,lo8(3)
  40 0020 8093 8304 		sts 1155,r24
  26:TakkI2C.c     **** 	// return 1 if ACK, 0 if NACK
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
  41               		.loc 1 27 0
  42 0024 8091 8404 		lds r24,1156
  43 0028 84FB      		bst r24,4
  44 002a 2227      		clr r18
  45 002c 20F9      		bld r18,0
  46 002e 30E0      		ldi r19,0
  47 0030 81E0      		ldi r24,1
  48 0032 2827      		eor r18,r24
  28:TakkI2C.c     **** }
  49               		.loc 1 28 0
  50 0034 822F      		mov r24,r18
  51 0036 0895      		ret
  52               	.L10:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
  53               		.loc 1 23 0
  54 0038 8091 8404 		lds r24,1156
  55 003c 86FD      		sbrc r24,6
  56 003e 00C0      		rjmp .L4
  57 0040 8091 8404 		lds r24,1156
  58 0044 86FF      		sbrs r24,6
  59 0046 00C0      		rjmp .L10
  60 0048 00C0      		rjmp .L4
  61               		.cfi_endproc
  62               	.LFE80:
  64               	.global	EVENT_USB_Device_ConfigurationChanged
  66               	EVENT_USB_Device_ConfigurationChanged:
  67               	.LFB57:
  68               		.file 2 "TakkTile.h"
   1:TakkTile.h    **** #pragma once
   2:TakkTile.h    **** #define F_CPU 32000000UL
   3:TakkTile.h    **** 
   4:TakkTile.h    **** // includes
   5:TakkTile.h    **** #include <avr/interrupt.h>
   6:TakkTile.h    **** #include <util/delay.h>
   7:TakkTile.h    **** #include "Descriptors.h"
   8:TakkTile.h    **** #include "usb/usb.h"
   9:TakkTile.h    **** #include "usb/usb_pipe.h"
  10:TakkTile.h    **** #include <avr/eeprom.h>
  11:TakkTile.h    **** #include <avr/io.h>
  12:TakkTile.h    **** 
  13:TakkTile.h    **** bool SLAVE = 1;
  14:TakkTile.h    **** bool MASTER = 0;
  15:TakkTile.h    **** bool timeout_or_sampling_no_longer_enabled = 1;
  16:TakkTile.h    **** 
  17:TakkTile.h    **** USB_PIPE(ep_in, 0x81 | USB_EP_PP, USB_EP_TYPE_BULK_gc, 64, 8, PIPE_ENABLE_FLUSH);
  18:TakkTile.h    **** 
  19:TakkTile.h    **** // Queue a byte to be sent over the bulk EP. Blocks if the buffer is full
  20:TakkTile.h    **** static inline void send_byte(uint8_t byte){
  21:TakkTile.h    ****     // this should never actually block if your buffer is big enough
  22:TakkTile.h    ****     while (!usb_pipe_can_write(&ep_in));
  23:TakkTile.h    **** 	usb_pipe_write_byte(&ep_in, byte);
  24:TakkTile.h    **** }
  25:TakkTile.h    **** 
  26:TakkTile.h    **** // Sends a break to end the USB read and flushes the USB pipe
  27:TakkTile.h    **** static inline void break_and_flush(){
  28:TakkTile.h    ****     usb_pipe_flush(&ep_in);
  29:TakkTile.h    ****     USB.INTFLAGSBSET = USB_TRNIF_bm;
  30:TakkTile.h    ****     while (!usb_pipe_can_write(&ep_in)){
  31:TakkTile.h    ****         if (timeout_or_sampling_no_longer_enabled){
  32:TakkTile.h    ****             usb_pipe_reset(&ep_in);
  33:TakkTile.h    ****             return;
  34:TakkTile.h    ****         }
  35:TakkTile.h    ****     }
  36:TakkTile.h    **** } 
  37:TakkTile.h    **** 
  38:TakkTile.h    **** void EVENT_USB_Device_ConfigurationChanged(uint8_t config){
  69               		.loc 2 38 0
  70               		.cfi_startproc
  71               	.LVL2:
  72               	/* prologue: function */
  73               	/* frame size = 0 */
  74               	/* stack size = 0 */
  75               	.L__stack_usage = 0
  76               	.LBB253:
  77               	.LBB254:
  78               	.LBB255:
  79               		.file 3 "usb/usb_pipe.h"
   1:usb/usb_pipe.h **** #include "pipe.h"
   2:usb/usb_pipe.h **** #include "usb.h"
   3:usb/usb_pipe.h **** 
   4:usb/usb_pipe.h **** #include <util/atomic.h>
   5:usb/usb_pipe.h **** #ifndef PIPE_ATOMIC
   6:usb/usb_pipe.h **** #define PIPE_ATOMIC ATOMIC_RESTORESTATE
   7:usb/usb_pipe.h **** #endif 
   8:usb/usb_pipe.h **** 
   9:usb/usb_pipe.h **** typedef struct USB_Pipe_data{
  10:usb/usb_pipe.h **** 	bool bank;
  11:usb/usb_pipe.h **** 	uint8_t flush;
  12:usb/usb_pipe.h **** 	uint16_t packet_offset; // Index into current packet for byte mode
  13:usb/usb_pipe.h **** } USB_Pipe_data;
  14:usb/usb_pipe.h **** 
  15:usb/usb_pipe.h **** // Immutable part, constant-folded at compile time
  16:usb/usb_pipe.h **** typedef struct USB_Pipe{
  17:usb/usb_pipe.h **** 	uint8_t ep;
  18:usb/usb_pipe.h **** 	uint8_t type;
  19:usb/usb_pipe.h **** 	USB_Pipe_data* data;
  20:usb/usb_pipe.h **** 	const Pipe* pipe;
  21:usb/usb_pipe.h **** 	uint8_t features;
  22:usb/usb_pipe.h **** } USB_Pipe;
  23:usb/usb_pipe.h **** 
  24:usb/usb_pipe.h **** #define PIPE_ENABLE_FLUSH (1<<0)
  25:usb/usb_pipe.h **** 
  26:usb/usb_pipe.h **** #define USB_PIPE(NAME, EPNO, TYPE, PACKET_SIZE, BUFFER_PACKETS, FEATURES) \
  27:usb/usb_pipe.h **** 	PIPE(NAME##_pipe, (BUFFER_PACKETS), (PACKET_SIZE),               \
  28:usb/usb_pipe.h **** 		((EPNO)&USB_EP_IN)?0:2,                      \
  29:usb/usb_pipe.h **** 		((EPNO)&USB_EP_IN)?2:0                       \
  30:usb/usb_pipe.h **** 	);                                               \
  31:usb/usb_pipe.h **** 	USB_Pipe_data NAME##_data = {      \
  32:usb/usb_pipe.h **** 		.bank = 0,                   \
  33:usb/usb_pipe.h **** 		.flush = 0,                    \
  34:usb/usb_pipe.h **** 	};                                 \
  35:usb/usb_pipe.h **** 	const static USB_Pipe NAME = {     \
  36:usb/usb_pipe.h **** 		.ep = (EPNO),                  \
  37:usb/usb_pipe.h **** 		.type = (TYPE),                \
  38:usb/usb_pipe.h **** 		.data = &(NAME##_data),        \
  39:usb/usb_pipe.h **** 		.pipe = &(NAME##_pipe),        \
  40:usb/usb_pipe.h **** 		.features = (FEATURES),        \
  41:usb/usb_pipe.h **** 	};                                 \
  42:usb/usb_pipe.h **** 
  43:usb/usb_pipe.h **** static inline void usb_pipe_init(const USB_Pipe* p){
  44:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  80               		.loc 3 44 0
  81 004a 2FB7      		in r18,__SREG__
  82               	.LVL3:
  83               	.LBB256:
  84               	.LBB257:
  85               		.file 4 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/
   1:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
   4:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
   7:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
  10:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****      distribution.
  14:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
  15:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
  19:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** */
  31:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
  32:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** /* $Id: atomic.h 2158 2010-06-10 15:48:28Z joerg_wunsch $ */
  33:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
  34:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
  37:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
  40:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** {
  44:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     sei();
  45:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     return 1;
  46:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** }
  47:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
  48:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** {
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
  86               		.loc 4 50 0
  87               	/* #APP */
  88               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
  89 004c F894      		cli
  90               	 ;  0 "" 2
  91               	.LVL4:
  92               	/* #NOAPP */
  93               	.LBE257:
  94               	.LBE256:
  95               	.LBB258:
  96               	.LBB259:
  97               		.file 5 "usb/pipe.h"
   1:usb/pipe.h    **** // Ring buffer that takes heavy advantage of constant folding
   2:usb/pipe.h    **** #pragma once
   3:usb/pipe.h    **** 
   4:usb/pipe.h    **** #include "Common.h"
   5:usb/pipe.h    **** 
   6:usb/pipe.h    **** // Mutable part, becomes an actual struct
   7:usb/pipe.h    **** typedef struct Pipe_data{
   8:usb/pipe.h    **** 	uint8_t* read_ptr;
   9:usb/pipe.h    **** 	uint8_t* write_ptr;
  10:usb/pipe.h    **** 	int8_t count; // available slots
  11:usb/pipe.h    **** } Pipe_data;
  12:usb/pipe.h    **** 
  13:usb/pipe.h    **** // Immutable part, constant-folded at compile time
  14:usb/pipe.h    **** typedef struct Pipe{
  15:usb/pipe.h    **** 	Pipe_data* data;
  16:usb/pipe.h    **** 	uint8_t* buffer;
  17:usb/pipe.h    **** 	uint8_t  slots;         // Number of slots in the buffer
  18:usb/pipe.h    **** 	uint8_t reserve_read;  // Slots to prevent reading so they are available to writer
  19:usb/pipe.h    **** 	uint8_t reserve_write; // Slots to prevent writing so they are available to reader
  20:usb/pipe.h    **** 	uint16_t size;          // Size of a buffer slot in bytes
  21:usb/pipe.h    **** } Pipe;
  22:usb/pipe.h    **** 
  23:usb/pipe.h    **** #define PIPE_H(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE)       \
  24:usb/pipe.h    **** 	extern Pipe_data NAME##_data;         \
  25:usb/pipe.h    **** 	extern uint8_t NAME##_buffer[(SLOTS)*(SIZE)]; \
  26:usb/pipe.h    **** 	const static Pipe NAME = {            \
  27:usb/pipe.h    **** 		.data = &(NAME##_data),           \
  28:usb/pipe.h    **** 		.buffer = &((NAME##_buffer)[0]),  \
  29:usb/pipe.h    **** 		.slots = (SLOTS),                 \
  30:usb/pipe.h    **** 		.size = (SIZE),                   \
  31:usb/pipe.h    **** 		.reserve_read = (RESERVE_READ),   \
  32:usb/pipe.h    **** 		.reserve_write = (RESERVE_WRITE), \
  33:usb/pipe.h    **** 	};
  34:usb/pipe.h    **** 
  35:usb/pipe.h    **** 
  36:usb/pipe.h    **** #define PIPE_C(NAME, SLOTS, SIZE)                   \
  37:usb/pipe.h    **** 	uint8_t NAME##_buffer[(SLOTS)*(SIZE)];           \
  38:usb/pipe.h    **** 	Pipe_data NAME##_data = {                \
  39:usb/pipe.h    **** 		.count = 0,                          \
  40:usb/pipe.h    **** 		.read_ptr = &((NAME##_buffer)[0]),                       \
  41:usb/pipe.h    **** 		.write_ptr = &((NAME##_buffer)[0]),                      \
  42:usb/pipe.h    **** 	};
  43:usb/pipe.h    **** 
  44:usb/pipe.h    **** #define PIPE(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE) \
  45:usb/pipe.h    **** 	PIPE_H(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE)   \
  46:usb/pipe.h    **** 	PIPE_C(NAME, SLOTS, SIZE)
  47:usb/pipe.h    **** 
  48:usb/pipe.h    **** // Number of slots available to read
  49:usb/pipe.h    **** static inline int8_t pipe_can_read(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  50:usb/pipe.h    **** static inline int8_t pipe_can_read(const Pipe* pipe){
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
  52:usb/pipe.h    **** }
  53:usb/pipe.h    **** 
  54:usb/pipe.h    **** // Number of slots available to write
  55:usb/pipe.h    **** static inline int8_t pipe_can_write(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  56:usb/pipe.h    **** static inline int8_t pipe_can_write(const Pipe* pipe){
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
  58:usb/pipe.h    **** }
  59:usb/pipe.h    **** 
  60:usb/pipe.h    **** static inline uint8_t* pipe_read_ptr(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  61:usb/pipe.h    **** static inline uint8_t* pipe_read_ptr(const Pipe* pipe){
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
  63:usb/pipe.h    **** }
  64:usb/pipe.h    **** 
  65:usb/pipe.h    **** static inline uint8_t* pipe_write_ptr(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  66:usb/pipe.h    **** static inline uint8_t* pipe_write_ptr(const Pipe* pipe){
  67:usb/pipe.h    **** 	return pipe->data->write_ptr;
  68:usb/pipe.h    **** }
  69:usb/pipe.h    **** 
  70:usb/pipe.h    **** static inline void pipe_done_read(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  71:usb/pipe.h    **** static inline void pipe_done_read(const Pipe* pipe){
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
  74:usb/pipe.h    **** 	// Assumes buffer_size % slot_size == 0 and all accesses aligned
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
  77:usb/pipe.h    **** }
  78:usb/pipe.h    **** 
  79:usb/pipe.h    **** static inline void pipe_done_write(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  80:usb/pipe.h    **** static inline void pipe_done_write(const Pipe* pipe){
  81:usb/pipe.h    **** 	pipe->data->count += 1;
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
  83:usb/pipe.h    **** 	// Assumes buffer_size % slot_size == 0 and all accesses aligned
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
  86:usb/pipe.h    **** }
  87:usb/pipe.h    **** 
  88:usb/pipe.h    **** static inline void pipe_reset(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  89:usb/pipe.h    **** static inline void pipe_reset(const Pipe* pipe){
  90:usb/pipe.h    **** 	pipe->data->count = 0;
  98               		.loc 5 90 0
  99 004e 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
  91:usb/pipe.h    **** 	pipe->data->read_ptr = pipe->data->write_ptr = pipe->buffer;
 100               		.loc 5 91 0
 101 0052 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 102 0054 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 103               	.LVL5:
 104 0056 8093 0000 		sts ep_in_pipe_data+2,r24
 105 005a 9093 0000 		sts ep_in_pipe_data+2+1,r25
 106 005e 8093 0000 		sts ep_in_pipe_data,r24
 107 0062 9093 0000 		sts ep_in_pipe_data+1,r25
 108               	.LVL6:
 109               	.LBE259:
 110               	.LBE258:
 111               	.LBB260:
 112               	.LBB261:
 113               	.LBB262:
 114               		.file 6 "usb/usb.h"
   1:usb/usb.h     **** // Minimal USB Stack for ATxmega32a4u and related
   2:usb/usb.h     **** // http://nonolithlabs.com
   3:usb/usb.h     **** // (C) 2011 Kevin Mehall (Nonolith Labs) <km@kevinmehall.net>
   4:usb/usb.h     **** //
   5:usb/usb.h     **** // Heavily borrows from LUFA
   6:usb/usb.h     **** // Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
   7:usb/usb.h     **** //
   8:usb/usb.h     **** // Licensed under the terms of the GNU GPLv3+
   9:usb/usb.h     **** 
  10:usb/usb.h     **** #pragma once
  11:usb/usb.h     **** 
  12:usb/usb.h     **** #include <avr/io.h>
  13:usb/usb.h     **** 
  14:usb/usb.h     **** #define CPU_TO_LE16(x) x
  15:usb/usb.h     **** 
  16:usb/usb.h     **** struct USB_Request_Header;
  17:usb/usb.h     **** typedef struct USB_Request_Header USB_Requst_Header_t;
  18:usb/usb.h     **** 
  19:usb/usb.h     **** #include "StdDescriptors.h"
  20:usb/usb.h     **** #include "StdRequestType.h"
  21:usb/usb.h     **** #include "Events.h"
  22:usb/usb.h     **** 
  23:usb/usb.h     **** #ifndef USB_MAXEP
  24:usb/usb.h     **** 	#define USB_MAXEP 1
  25:usb/usb.h     **** #endif
  26:usb/usb.h     **** 
  27:usb/usb.h     **** #ifndef USB_EP0SIZE
  28:usb/usb.h     **** 	#define EP0SIZE 64
  29:usb/usb.h     **** #endif
  30:usb/usb.h     **** 
  31:usb/usb.h     **** typedef union USB_EP_pair{
  32:usb/usb.h     **** 	union{
  33:usb/usb.h     **** 		struct{
  34:usb/usb.h     **** 			USB_EP_t out;
  35:usb/usb.h     **** 			USB_EP_t in;
  36:usb/usb.h     **** 		};
  37:usb/usb.h     **** 		USB_EP_t ep[2];
  38:usb/usb.h     **** 	};
  39:usb/usb.h     **** } ATTR_PACKED USB_EP_pair_t;
  40:usb/usb.h     **** 
  41:usb/usb.h     **** extern uint8_t ep0_buf_in[USB_EP0SIZE];
  42:usb/usb.h     **** extern uint8_t ep0_buf_out[USB_EP0SIZE];
  43:usb/usb.h     **** extern USB_EP_pair_t endpoints[USB_MAXEP+1];
  44:usb/usb.h     **** 
  45:usb/usb.h     **** /** String descriptor index for the device's unique serial number string descriptor within the devi
  46:usb/usb.h     ****  *  This unique serial number is used by the host to associate resources to the device (such as dri
  47:usb/usb.h     ****  *  number allocations) to a device regardless of the port it is plugged in to on the host. Some mi
  48:usb/usb.h     ****  *  a unique serial number internally, and setting the device descriptors serial number string inde
  49:usb/usb.h     ****  *  will cause it to use the internal serial number.
  50:usb/usb.h     ****  *
  51:usb/usb.h     ****  *  On unsupported devices, this will evaluate to \ref NO_DESCRIPTOR and so will force the host to 
  52:usb/usb.h     ****  *  number for the device.
  53:usb/usb.h     ****  */
  54:usb/usb.h     **** #define USE_INTERNAL_SERIAL            0xDC
  55:usb/usb.h     **** 
  56:usb/usb.h     **** /** Length of the device's unique internal serial number, in bits, if present on the selected micro
  57:usb/usb.h     ****  *  model.
  58:usb/usb.h     ****  */
  59:usb/usb.h     **** #define INTERNAL_SERIAL_LENGTH_BITS    (8 * (1 + (offsetof(NVM_PROD_SIGNATURES_t, COORDY1) - offset
  60:usb/usb.h     **** 
  61:usb/usb.h     **** /** Start address of the internal serial number, in the appropriate address space, if present on th
  62:usb/usb.h     ****  *  model.
  63:usb/usb.h     ****  */
  64:usb/usb.h     **** #define INTERNAL_SERIAL_START_ADDRESS  offsetof(NVM_PROD_SIGNATURES_t, LOTNUM0)
  65:usb/usb.h     **** 
  66:usb/usb.h     **** /* Enums: */
  67:usb/usb.h     **** 	/** Enum for the various states of the USB Device state machine. Only some states are
  68:usb/usb.h     **** 	 *  implemented in the LUFA library - other states are left to the user to implement.
  69:usb/usb.h     **** 	 *
  70:usb/usb.h     **** 	 *  For information on each possible USB device state, refer to the USB 2.0 specification.
  71:usb/usb.h     **** 	 *
  72:usb/usb.h     **** 	 *  \see \ref USB_DeviceState, which stores the current device state machine state.
  73:usb/usb.h     **** 	 */
  74:usb/usb.h     **** 	enum USB_Device_States_t
  75:usb/usb.h     **** 	{
  76:usb/usb.h     **** 		DEVICE_STATE_Unattached                   = 0, /**< Internally implemented by the library. This s
  77:usb/usb.h     **** 		                                                *   that the device is not currently connected to
  78:usb/usb.h     **** 		                                                */
  79:usb/usb.h     **** 		DEVICE_STATE_Powered                      = 1, /**< Internally implemented by the library. This s
  80:usb/usb.h     **** 		                                                *   that the device is connected to a host, but e
  81:usb/usb.h     **** 		                                                *   yet begun.
  82:usb/usb.h     **** 		                                                */
  83:usb/usb.h     **** 		DEVICE_STATE_Default                      = 2, /**< Internally implemented by the library. This s
  84:usb/usb.h     **** 		                                                *   that the device's USB bus has been reset by t
  85:usb/usb.h     **** 		                                                *   now waiting for the host to begin the enumera
  86:usb/usb.h     **** 		                                                */
  87:usb/usb.h     **** 		DEVICE_STATE_Addressed                    = 3, /**< Internally implemented by the library. This s
  88:usb/usb.h     **** 		                                                *   that the device has been addressed by the USB
  89:usb/usb.h     **** 		                                                *   yet configured.
  90:usb/usb.h     **** 		                                                */
  91:usb/usb.h     **** 		DEVICE_STATE_Configured                   = 4, /**< May be implemented by the user project. This 
  92:usb/usb.h     **** 		                                                *   that the device has been enumerated by the ho
  93:usb/usb.h     **** 		                                                *   for USB communications to begin.
  94:usb/usb.h     **** 		                                                */
  95:usb/usb.h     **** 		DEVICE_STATE_Suspended                    = 5, /**< May be implemented by the user project. This 
  96:usb/usb.h     **** 		                                                *   that the USB bus has been suspended by the ho
  97:usb/usb.h     **** 		                                                *   should power down to a minimal power level un
  98:usb/usb.h     **** 		                                                *   resumed.
  99:usb/usb.h     **** 		                                                */
 100:usb/usb.h     **** 	};
 101:usb/usb.h     **** 
 102:usb/usb.h     **** #define USB_EP_size_to_gc(x)  ((x <= 8   )?USB_EP_BUFSIZE_8_gc:\
 103:usb/usb.h     ****                                (x <= 16  )?USB_EP_BUFSIZE_16_gc:\
 104:usb/usb.h     ****                                (x <= 32  )?USB_EP_BUFSIZE_32_gc:\
 105:usb/usb.h     ****                                (x <= 64  )?USB_EP_BUFSIZE_64_gc:\
 106:usb/usb.h     ****                                (x <= 128 )?USB_EP_BUFSIZE_128_gc:\
 107:usb/usb.h     ****                                (x <= 256 )?USB_EP_BUFSIZE_256_gc:\
 108:usb/usb.h     ****                                (x <= 512 )?USB_EP_BUFSIZE_512_gc:\
 109:usb/usb.h     ****                                            USB_EP_BUFSIZE_1023_gc)
 110:usb/usb.h     **** 
 111:usb/usb.h     **** #define USB_EP_IN 0x80
 112:usb/usb.h     **** 
 113:usb/usb.h     **** // Flag in the endpoint address to indicate that the endpoint should use
 114:usb/usb.h     **** // PingPong (double buffer) mode. This is not actually part of the endpoint
 115:usb/usb.h     **** // address as seen by the host. If PP is enabled, this flag needs to be part
 116:usb/usb.h     **** // of the address passed to all USB_EP_* functions.
 117:usb/usb.h     **** #define USB_EP_PP 0x40
 118:usb/usb.h     **** 	
 119:usb/usb.h     **** extern volatile uint8_t USB_DeviceState;
 120:usb/usb.h     **** extern volatile uint8_t USB_Device_ConfigurationNumber;
 121:usb/usb.h     **** 
 122:usb/usb.h     **** /** Configure the XMEGA's clock for use with USB.  */
 123:usb/usb.h     **** void USB_ConfigureClock(void);
 124:usb/usb.h     **** 
 125:usb/usb.h     **** /** Initialize USB functionality */
 126:usb/usb.h     **** void USB_Init(void);
 127:usb/usb.h     **** void USB_ResetInterface(void);
 128:usb/usb.h     **** 
 129:usb/usb.h     **** #define _USB_EP(epaddr) \
 130:usb/usb.h     **** 	USB_EP_pair_t* pair = &endpoints[(epaddr & 0x3F)]; \
 131:usb/usb.h     **** 	USB_EP_t* e __attribute__ ((unused)) = &pair->ep[!!(epaddr&0x80)]; \
 132:usb/usb.h     **** 	
 133:usb/usb.h     **** #define _USB_EP_OTHER(epaddr) \
 134:usb/usb.h     **** 	USB_EP_t* other = &pair->ep[!(epaddr&0x80)]
 135:usb/usb.h     **** 	
 136:usb/usb.h     **** #define _USB_EP_BANK(epaddr, bank) \
 137:usb/usb.h     **** 	USB_EP_t* b = &pair->ep[!!(epaddr&0x80) != bank]
 138:usb/usb.h     **** 
 139:usb/usb.h     **** inline void USB_ep_init(uint8_t ep, uint8_t type, uint16_t bufsize) ATTR_ALWAYS_INLINE;
 140:usb/usb.h     **** inline void USB_ep_init(uint8_t ep, uint8_t type, uint16_t bufsize){
 141:usb/usb.h     **** 	_USB_EP(ep);
 142:usb/usb.h     **** 	if (ep & USB_EP_PP){
 143:usb/usb.h     **** 		_USB_EP_OTHER(ep);
 144:usb/usb.h     **** 		e->STATUS = USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm;
 115               		.loc 6 144 0
 116 0066 86E0      		ldi r24,lo8(6)
 117 0068 8093 0000 		sts endpoints+24,r24
 145:usb/usb.h     **** 		e->CTRL = type | USB_EP_size_to_gc(bufsize) | USB_EP_PINGPONG_bm;
 118               		.loc 6 145 0
 119 006c 83E9      		ldi r24,lo8(-109)
 120 006e 8093 0000 		sts endpoints+25,r24
 146:usb/usb.h     **** 		other->CTRL = 0;
 121               		.loc 6 146 0
 122 0072 1092 0000 		sts endpoints+17,__zero_reg__
 147:usb/usb.h     **** 		other->STATUS = USB_EP_BUSNACK0_bm;
 123               		.loc 6 147 0
 124 0076 82E0      		ldi r24,lo8(2)
 125 0078 8093 0000 		sts endpoints+16,r24
 126               	.LBE262:
 127               	.LBE261:
 128               	.LBE260:
  45:usb/usb_pipe.h **** 		pipe_reset(p->pipe);
  46:usb/usb_pipe.h **** 		USB_ep_init(p->ep, p->type, p->pipe->size);
  47:usb/usb_pipe.h **** 		p->data->bank = 0;
 129               		.loc 3 47 0
 130 007c 1092 0000 		sts ep_in_data,__zero_reg__
  48:usb/usb_pipe.h **** 		p->data->flush = 0;
 131               		.loc 3 48 0
 132 0080 1092 0000 		sts ep_in_data+1,__zero_reg__
  49:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
 133               		.loc 3 49 0
 134 0084 1092 0000 		sts ep_in_data+2,__zero_reg__
 135 0088 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 136               	.LVL7:
 137               	.LBB263:
 138               	.LBB264:
  51:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     return 1;
  52:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** }
  53:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
  54:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** {
  56:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     sei();
  57:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  58:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     (void)__s;
  59:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** }
  60:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
  61:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** static __inline__ void __iCliParam(const uint8_t *__s)
  62:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** {
  63:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
  64:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  65:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     (void)__s;
  66:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** }
  67:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** 
  68:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** static __inline__ void __iRestore(const  uint8_t *__s)
  69:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h **** {
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 139               		.loc 4 70 0
 140 008c 2FBF      		out __SREG__,r18
  71:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 141               		.loc 4 71 0
 142 008e 0895      		ret
 143               	.LBE264:
 144               	.LBE263:
 145               	.LBE255:
 146               	.LBE254:
 147               	.LBE253:
 148               		.cfi_endproc
 149               	.LFE57:
 151               	.global	__vector_125
 153               	__vector_125:
 154               	.LFB58:
  39:TakkTile.h    **** 	usb_pipe_init(&ep_in);
  40:TakkTile.h    **** }
  41:TakkTile.h    **** 
  42:TakkTile.h    **** ISR(USB_BUSEVENT_vect){
 155               		.loc 2 42 0
 156               		.cfi_startproc
 157 0090 1F92      		push r1
 158               	.LCFI0:
 159               		.cfi_def_cfa_offset 3
 160               		.cfi_offset 1, -2
 161 0092 0F92      		push r0
 162               	.LCFI1:
 163               		.cfi_def_cfa_offset 4
 164               		.cfi_offset 0, -3
 165 0094 0FB6      		in r0,__SREG__
 166 0096 0F92      		push r0
 167 0098 1124      		clr __zero_reg__
 168 009a 2F93      		push r18
 169               	.LCFI2:
 170               		.cfi_def_cfa_offset 5
 171               		.cfi_offset 18, -4
 172 009c 3F93      		push r19
 173               	.LCFI3:
 174               		.cfi_def_cfa_offset 6
 175               		.cfi_offset 19, -5
 176 009e 4F93      		push r20
 177               	.LCFI4:
 178               		.cfi_def_cfa_offset 7
 179               		.cfi_offset 20, -6
 180 00a0 5F93      		push r21
 181               	.LCFI5:
 182               		.cfi_def_cfa_offset 8
 183               		.cfi_offset 21, -7
 184 00a2 6F93      		push r22
 185               	.LCFI6:
 186               		.cfi_def_cfa_offset 9
 187               		.cfi_offset 22, -8
 188 00a4 7F93      		push r23
 189               	.LCFI7:
 190               		.cfi_def_cfa_offset 10
 191               		.cfi_offset 23, -9
 192 00a6 8F93      		push r24
 193               	.LCFI8:
 194               		.cfi_def_cfa_offset 11
 195               		.cfi_offset 24, -10
 196 00a8 9F93      		push r25
 197               	.LCFI9:
 198               		.cfi_def_cfa_offset 12
 199               		.cfi_offset 25, -11
 200 00aa AF93      		push r26
 201               	.LCFI10:
 202               		.cfi_def_cfa_offset 13
 203               		.cfi_offset 26, -12
 204 00ac BF93      		push r27
 205               	.LCFI11:
 206               		.cfi_def_cfa_offset 14
 207               		.cfi_offset 27, -13
 208 00ae EF93      		push r30
 209               	.LCFI12:
 210               		.cfi_def_cfa_offset 15
 211               		.cfi_offset 30, -14
 212 00b0 FF93      		push r31
 213               	.LCFI13:
 214               		.cfi_def_cfa_offset 16
 215               		.cfi_offset 31, -15
 216               	/* prologue: Signal */
 217               	/* frame size = 0 */
 218               	/* stack size = 15 */
 219               	.L__stack_usage = 15
  43:TakkTile.h    **** 	if (USB.INTFLAGSACLR & USB_SOFIF_bm){
 220               		.loc 2 43 0
 221 00b2 8091 CA04 		lds r24,1226
 222 00b6 87FD      		sbrc r24,7
 223 00b8 00C0      		rjmp .L26
  44:TakkTile.h    **** 		USB.INTFLAGSACLR = USB_SOFIF_bm;
  45:TakkTile.h    **** 	}else if (USB.INTFLAGSACLR & (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm)){
 224               		.loc 2 45 0
 225 00ba 8091 CA04 		lds r24,1226
 226 00be 8E70      		andi r24,lo8(14)
 227 00c0 01F4      		brne .L27
  46:TakkTile.h    **** 		USB.INTFLAGSACLR = (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm);
  47:TakkTile.h    **** 	}else if (USB.INTFLAGSACLR & USB_STALLIF_bm){
 228               		.loc 2 47 0
 229 00c2 8091 CA04 		lds r24,1226
 230 00c6 80FD      		sbrc r24,0
 231 00c8 00C0      		rjmp .L28
  48:TakkTile.h    **** 		USB.INTFLAGSACLR = USB_STALLIF_bm;
  49:TakkTile.h    **** 	}else{
  50:TakkTile.h    **** 		USB.INTFLAGSACLR = USB_SUSPENDIF_bm | USB_RESUMEIF_bm | USB_RSTIF_bm;
 232               		.loc 2 50 0
 233 00ca 80E7      		ldi r24,lo8(112)
 234 00cc 8093 CA04 		sts 1226,r24
 235               	.LBB265:
 236               	.LBB266:
 148:usb/usb.h     **** 	}else{
 149:usb/usb.h     **** 		e->STATUS = USB_EP_BUSNACK0_bm;
 150:usb/usb.h     **** 		e->CTRL = type | USB_EP_size_to_gc(bufsize);
 151:usb/usb.h     **** 	}
 152:usb/usb.h     **** }
 153:usb/usb.h     **** 
 154:usb/usb.h     **** inline void USB_ep_cancel(uint8_t ep) ATTR_ALWAYS_INLINE;
 155:usb/usb.h     **** inline void USB_ep_cancel(uint8_t ep){
 156:usb/usb.h     **** 	_USB_EP(ep);
 157:usb/usb.h     **** 	if (ep & USB_EP_PP){
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 160:usb/usb.h     **** 	}else{
 161:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm);
 162:usb/usb.h     **** 	}
 163:usb/usb.h     **** }
 164:usb/usb.h     **** 
 165:usb/usb.h     **** inline void USB_ep_start_bank(uint8_t ep, uint8_t bank, uint8_t* addr, uint16_t size){
 166:usb/usb.h     **** 	_USB_EP(ep);
 167:usb/usb.h     **** 	_USB_EP_BANK(ep, bank);
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 170:usb/usb.h     **** 	
 171:usb/usb.h     **** 	//TODO: the OVF, STALL, and TRNCOMPL flags are in b->STATUS. Clear them if anyone cares.
 172:usb/usb.h     **** 
 173:usb/usb.h     **** 	if (bank==0){
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 175:usb/usb.h     **** 	}else{
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 177:usb/usb.h     **** 	}
 178:usb/usb.h     **** }
 179:usb/usb.h     **** 
 180:usb/usb.h     **** inline void USB_ep_out_start(uint8_t ep, uint8_t* addr) ATTR_ALWAYS_INLINE;
 181:usb/usb.h     **** inline void USB_ep_out_start(uint8_t ep, uint8_t* addr){
 182:usb/usb.h     **** 	USB_ep_start_bank(ep, 0, addr, 0);
 183:usb/usb.h     **** }
 184:usb/usb.h     **** 
 185:usb/usb.h     **** inline void USB_ep_in_start(uint8_t ep, uint8_t* addr, uint16_t size) ATTR_ALWAYS_INLINE;
 186:usb/usb.h     **** inline void USB_ep_in_start(uint8_t ep, uint8_t* addr, uint16_t size){
 187:usb/usb.h     **** 	USB_ep_start_bank(ep, 0, addr, size);
 188:usb/usb.h     **** }
 189:usb/usb.h     **** 
 190:usb/usb.h     **** inline bool USB_ep_done_bank(uint8_t ep, uint8_t bank){
 191:usb/usb.h     **** 	_USB_EP(ep);
 192:usb/usb.h     **** 	return e->STATUS & (bank?USB_EP_TRNCOMPL1_bm:USB_EP_TRNCOMPL0_bm);
 193:usb/usb.h     **** }
 194:usb/usb.h     **** 
 195:usb/usb.h     **** inline bool USB_ep_done(uint8_t ep) ATTR_ALWAYS_INLINE;
 196:usb/usb.h     **** inline bool USB_ep_done(uint8_t ep){
 197:usb/usb.h     **** 	_USB_EP(ep);
 198:usb/usb.h     **** 	if (ep & USB_EP_PP){
 199:usb/usb.h     **** 		return e->STATUS & (USB_EP_TRNCOMPL0_bm|USB_EP_TRNCOMPL1_bm);
 200:usb/usb.h     **** 	}else{
 201:usb/usb.h     **** 		// Because for ep0, TRNCOMPL1 is SETUP
 202:usb/usb.h     **** 		return e->STATUS & USB_EP_TRNCOMPL0_bm;
 203:usb/usb.h     **** 	}
 204:usb/usb.h     **** }
 205:usb/usb.h     **** 
 206:usb/usb.h     **** inline void USB_ep_clear_done(uint8_t ep) ATTR_ALWAYS_INLINE;
 207:usb/usb.h     **** inline void USB_ep_clear_done(uint8_t ep){
 208:usb/usb.h     **** 	_USB_EP(ep);
 209:usb/usb.h     **** 	if (ep & USB_EP_PP){
 210:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_TRNCOMPL0_bm|USB_EP_TRNCOMPL1_bm);
 211:usb/usb.h     **** 	}else{
 212:usb/usb.h     **** 		// Because for ep0, TRNCOMPL1 is SETUP
 213:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_TRNCOMPL0_bm);
 214:usb/usb.h     **** 	}
 215:usb/usb.h     **** }
 216:usb/usb.h     **** 
 217:usb/usb.h     **** inline bool USB_ep_ready(uint8_t ep) ATTR_ALWAYS_INLINE;
 218:usb/usb.h     **** inline bool USB_ep_ready(uint8_t ep){
 219:usb/usb.h     **** 	_USB_EP(ep);
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 221:usb/usb.h     **** }
 222:usb/usb.h     **** 
 223:usb/usb.h     **** inline bool USB_ep_empty(uint8_t ep) ATTR_ALWAYS_INLINE;
 224:usb/usb.h     **** inline bool USB_ep_empty(uint8_t ep){
 225:usb/usb.h     **** 	_USB_EP(ep);
 226:usb/usb.h     **** 	if (ep & USB_EP_PP){
 227:usb/usb.h     **** 		const uint8_t mask = (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 229:usb/usb.h     **** 	}else{
 230:usb/usb.h     **** 		return e->STATUS & USB_EP_BUSNACK0_bm;
 231:usb/usb.h     **** 	}
 232:usb/usb.h     **** }
 233:usb/usb.h     **** 
 234:usb/usb.h     **** inline uint16_t USB_ep_count_bank(uint8_t ep, uint8_t bank) ATTR_ALWAYS_INLINE;
 235:usb/usb.h     **** inline uint16_t USB_ep_count_bank(uint8_t ep, uint8_t bank){
 236:usb/usb.h     **** 	_USB_EP(ep);
 237:usb/usb.h     **** 	_USB_EP_BANK(ep, bank);
 238:usb/usb.h     **** 	return b->CNT;
 239:usb/usb.h     **** }
 240:usb/usb.h     **** 
 241:usb/usb.h     **** inline uint16_t USB_ep_count(uint8_t ep) ATTR_ALWAYS_INLINE;
 242:usb/usb.h     **** inline uint16_t USB_ep_count(uint8_t ep){
 243:usb/usb.h     **** 	return USB_ep_count_bank(ep, 0);
 244:usb/usb.h     **** }
 245:usb/usb.h     **** 
 246:usb/usb.h     **** inline void USB_ep0_send(uint8_t size){
 247:usb/usb.h     **** 	USB_ep_in_start(0x80, ep0_buf_in, size);
 248:usb/usb.h     **** }
 249:usb/usb.h     **** void USB_ep0_send_progmem(const uint8_t* addr, uint16_t size);
 250:usb/usb.h     **** 
 251:usb/usb.h     **** inline void USB_ep_wait(uint8_t ep) ATTR_ALWAYS_INLINE;
 252:usb/usb.h     **** inline void USB_ep_wait(uint8_t ep){
 253:usb/usb.h     **** 	while (!USB_ep_done(ep)){};
 254:usb/usb.h     **** }
 255:usb/usb.h     **** 
 256:usb/usb.h     **** /// Select a certain bank of an endpoint for the next transfer
 257:usb/usb.h     **** inline void USB_ep_set_bank(uint8_t ep, uint8_t bank) ATTR_ALWAYS_INLINE;
 258:usb/usb.h     **** inline void USB_ep_set_bank(uint8_t ep, uint8_t bank){
 259:usb/usb.h     **** 	_USB_EP(ep);
 260:usb/usb.h     **** 	if (bank){
 261:usb/usb.h     **** 		LASR16(&(e->STATUS), USB_EP_BANK_bm);
 262:usb/usb.h     **** 	}else{
 263:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BANK_bm);
 264:usb/usb.h     **** 	}
 265:usb/usb.h     **** }
 266:usb/usb.h     **** 
 267:usb/usb.h     **** /// Get the bank 0/1 which will handle the next request on this endpoint
 268:usb/usb.h     **** inline uint8_t USB_ep_get_bank(uint8_t ep) ATTR_ALWAYS_INLINE;
 269:usb/usb.h     **** inline uint8_t USB_ep_get_bank(uint8_t ep){
 270:usb/usb.h     **** 	_USB_EP(ep);
 271:usb/usb.h     **** 	return !!(e->STATUS & USB_EP_BANK_bm);
 272:usb/usb.h     **** }
 273:usb/usb.h     **** 
 274:usb/usb.h     **** 
 275:usb/usb.h     **** // Enable the OUT stage on the default control pipe. This happens automatically
 276:usb/usb.h     **** // upon the return of HandleSetup, but use this function if it needs to happen
 277:usb/usb.h     **** // before returning (e.g. with USB_ep_wait()).
 278:usb/usb.h     **** inline void USB_ep0_enableOut(void) ATTR_ALWAYS_INLINE;
 279:usb/usb.h     **** inline void USB_ep0_enableOut(void){
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 281:usb/usb.h     **** }
 282:usb/usb.h     **** 
 283:usb/usb.h     **** bool USB_HandleSetup(void);
 284:usb/usb.h     **** 
 285:usb/usb.h     **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 286:usb/usb.h     ****                                     const uint8_t wIndex,
 287:usb/usb.h     ****                                     const void** const DescriptorAddress);
 288:usb/usb.h     **** 
 289:usb/usb.h     **** /** Detaches the device from the USB bus. This has the effect of removing the device from any
 290:usb/usb.h     ****  *  attached host, ceasing USB communications. If no host is present, this prevents any host from
 291:usb/usb.h     ****  *  enumerating the device once attached until \ref USB_Attach() is called.
 292:usb/usb.h     ****  */
 293:usb/usb.h     **** static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
 294:usb/usb.h     **** static inline void USB_Detach(void)
 295:usb/usb.h     **** {
 296:usb/usb.h     **** 	USB.CTRLB &= ~USB_ATTACH_bm;
 297:usb/usb.h     **** }
 298:usb/usb.h     **** 
 299:usb/usb.h     **** /** Attaches the device to the USB bus. This announces the device's presence to any attached
 300:usb/usb.h     ****  *  USB host, starting the enumeration process. If no host is present, attaching the device
 301:usb/usb.h     ****  *  will allow for enumeration once a host is connected to the device.
 302:usb/usb.h     ****  */
 303:usb/usb.h     **** static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
 304:usb/usb.h     **** static inline void USB_Attach(void)
 305:usb/usb.h     **** {
 306:usb/usb.h     **** 	USB.CTRLB |= USB_ATTACH_bm;
 307:usb/usb.h     **** }
 308:usb/usb.h     **** 
 309:usb/usb.h     **** inline void USB_Evt_Task(void) ATTR_ALWAYS_INLINE;
 310:usb/usb.h     **** inline void USB_Evt_Task(void){
 311:usb/usb.h     **** 	if (USB.STATUS & USB_BUSRST_bm){
 237               		.loc 6 311 0
 238 00d0 8091 C204 		lds r24,1218
 239 00d4 80FF      		sbrs r24,0
 240 00d6 00C0      		rjmp .L18
 312:usb/usb.h     **** 		USB.STATUS &= ~USB_BUSRST_bm;
 241               		.loc 6 312 0
 242 00d8 8091 C204 		lds r24,1218
 243 00dc 8E7F      		andi r24,lo8(-2)
 244 00de 8093 C204 		sts 1218,r24
 313:usb/usb.h     **** 		USB_Init();
 245               		.loc 6 313 0
 246 00e2 0E94 0000 		call USB_Init
 247               	.LVL8:
 248 00e6 00C0      		rjmp .L18
 249               	.L27:
 250               	.LBE266:
 251               	.LBE265:
  46:TakkTile.h    **** 		USB.INTFLAGSACLR = (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm);
 252               		.loc 2 46 0
 253 00e8 8EE0      		ldi r24,lo8(14)
 254 00ea 8093 CA04 		sts 1226,r24
 255               	.L18:
 256               	/* epilogue start */
  51:TakkTile.h    **** 		USB_Evt_Task();
  52:TakkTile.h    **** 	}
  53:TakkTile.h    **** }
 257               		.loc 2 53 0
 258 00ee FF91      		pop r31
 259 00f0 EF91      		pop r30
 260 00f2 BF91      		pop r27
 261 00f4 AF91      		pop r26
 262 00f6 9F91      		pop r25
 263 00f8 8F91      		pop r24
 264 00fa 7F91      		pop r23
 265 00fc 6F91      		pop r22
 266 00fe 5F91      		pop r21
 267 0100 4F91      		pop r20
 268 0102 3F91      		pop r19
 269 0104 2F91      		pop r18
 270 0106 0F90      		pop r0
 271 0108 0FBE      		out __SREG__,r0
 272 010a 0F90      		pop r0
 273 010c 1F90      		pop r1
 274 010e 1895      		reti
 275               	.L28:
  48:TakkTile.h    **** 		USB.INTFLAGSACLR = USB_STALLIF_bm;
 276               		.loc 2 48 0
 277 0110 81E0      		ldi r24,lo8(1)
 278 0112 8093 CA04 		sts 1226,r24
 279 0116 00C0      		rjmp .L18
 280               	.L26:
  44:TakkTile.h    **** 		USB.INTFLAGSACLR = USB_SOFIF_bm;
 281               		.loc 2 44 0
 282 0118 80E8      		ldi r24,lo8(-128)
 283 011a 8093 CA04 		sts 1226,r24
 284 011e 00C0      		rjmp .L18
 285               		.cfi_endproc
 286               	.LFE58:
 288               	.global	__vector_126
 290               	__vector_126:
 291               	.LFB59:
  54:TakkTile.h    **** 
  55:TakkTile.h    **** ISR(USB_TRNCOMPL_vect){
 292               		.loc 2 55 0
 293               		.cfi_startproc
 294 0120 1F92      		push r1
 295               	.LCFI14:
 296               		.cfi_def_cfa_offset 3
 297               		.cfi_offset 1, -2
 298 0122 0F92      		push r0
 299               	.LCFI15:
 300               		.cfi_def_cfa_offset 4
 301               		.cfi_offset 0, -3
 302 0124 0FB6      		in r0,__SREG__
 303 0126 0F92      		push r0
 304 0128 1124      		clr __zero_reg__
 305 012a 0F93      		push r16
 306               	.LCFI16:
 307               		.cfi_def_cfa_offset 5
 308               		.cfi_offset 16, -4
 309 012c 2F93      		push r18
 310               	.LCFI17:
 311               		.cfi_def_cfa_offset 6
 312               		.cfi_offset 18, -5
 313 012e 3F93      		push r19
 314               	.LCFI18:
 315               		.cfi_def_cfa_offset 7
 316               		.cfi_offset 19, -6
 317 0130 4F93      		push r20
 318               	.LCFI19:
 319               		.cfi_def_cfa_offset 8
 320               		.cfi_offset 20, -7
 321 0132 5F93      		push r21
 322               	.LCFI20:
 323               		.cfi_def_cfa_offset 9
 324               		.cfi_offset 21, -8
 325 0134 6F93      		push r22
 326               	.LCFI21:
 327               		.cfi_def_cfa_offset 10
 328               		.cfi_offset 22, -9
 329 0136 7F93      		push r23
 330               	.LCFI22:
 331               		.cfi_def_cfa_offset 11
 332               		.cfi_offset 23, -10
 333 0138 8F93      		push r24
 334               	.LCFI23:
 335               		.cfi_def_cfa_offset 12
 336               		.cfi_offset 24, -11
 337 013a 9F93      		push r25
 338               	.LCFI24:
 339               		.cfi_def_cfa_offset 13
 340               		.cfi_offset 25, -12
 341 013c AF93      		push r26
 342               	.LCFI25:
 343               		.cfi_def_cfa_offset 14
 344               		.cfi_offset 26, -13
 345 013e BF93      		push r27
 346               	.LCFI26:
 347               		.cfi_def_cfa_offset 15
 348               		.cfi_offset 27, -14
 349 0140 EF93      		push r30
 350               	.LCFI27:
 351               		.cfi_def_cfa_offset 16
 352               		.cfi_offset 30, -15
 353 0142 FF93      		push r31
 354               	.LCFI28:
 355               		.cfi_def_cfa_offset 17
 356               		.cfi_offset 31, -16
 357               	/* prologue: Signal */
 358               	/* frame size = 0 */
 359               	/* stack size = 16 */
 360               	.L__stack_usage = 16
  56:TakkTile.h    **** 	USB.FIFOWP = 0;
 361               		.loc 2 56 0
 362 0144 1092 C404 		sts 1220,__zero_reg__
  57:TakkTile.h    **** 	USB.INTFLAGSBCLR = USB_SETUPIF_bm | USB_TRNIF_bm;
 363               		.loc 2 57 0
 364 0148 83E0      		ldi r24,lo8(3)
 365 014a 8093 CC04 		sts 1228,r24
 366               	.LVL9:
 367               	.LBB321:
 368               	.LBB322:
  50:usb/usb_pipe.h **** 	}
  51:usb/usb_pipe.h **** }
  52:usb/usb_pipe.h **** 
  53:usb/usb_pipe.h **** static inline void usb_pipe_reset(const USB_Pipe* p){
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  55:usb/usb_pipe.h **** 		pipe_reset(p->pipe);
  56:usb/usb_pipe.h **** 		USB_ep_cancel(p->ep);
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
  60:usb/usb_pipe.h **** 	}
  61:usb/usb_pipe.h **** }
  62:usb/usb_pipe.h **** 
  63:usb/usb_pipe.h **** static inline void _usb_pipe_ep_start(const USB_Pipe* p, uint8_t* data, uint16_t size) ATTR_ALWAYS_
  64:usb/usb_pipe.h **** static inline void _usb_pipe_ep_start(const USB_Pipe* p, uint8_t* data, uint16_t size){
  65:usb/usb_pipe.h **** 	bool bank = 0;
  66:usb/usb_pipe.h **** 
  67:usb/usb_pipe.h **** 	if (p->ep & USB_EP_PP){
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
  70:usb/usb_pipe.h **** 	}
  71:usb/usb_pipe.h **** 
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
  73:usb/usb_pipe.h **** 		USB_ep_start_bank(p->ep, 0, data, size);
  74:usb/usb_pipe.h **** 	}else{
  75:usb/usb_pipe.h **** 		USB_ep_start_bank(p->ep, 1, data, size);
  76:usb/usb_pipe.h **** 	}
  77:usb/usb_pipe.h **** }
  78:usb/usb_pipe.h **** 
  79:usb/usb_pipe.h **** static inline void usb_pipe_handle(const USB_Pipe* p){
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 369               		.loc 3 80 0
 370 014e 5FB7      		in r21,__SREG__
 371               	.LVL10:
 372               	.LBB323:
 373               	.LBB324:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 374               		.loc 4 50 0
 375               	/* #APP */
 376               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 377 0150 F894      		cli
 378               	 ;  0 "" 2
 379               	.LVL11:
 380               	/* #NOAPP */
 381               	.LBE324:
 382               	.LBE323:
 383               	.LBB325:
 384               	.LBB326:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 385               		.loc 6 220 0
 386 0152 E0E0      		ldi r30,lo8(endpoints+24)
 387 0154 F0E0      		ldi r31,hi8(endpoints+24)
 388               	.LVL12:
 389 0156 8091 0000 		lds r24,endpoints+24
 390               	.LBE326:
 391 015a 8670      		andi r24,lo8(6)
 392               	.LBE325:
  81:usb/usb_pipe.h **** 		if (p->ep & USB_EP_IN){
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 393               		.loc 3 82 0
 394 015c 01F4      		brne .L49
 395               	.LVL13:
 396               	.L30:
 397               	.LBB327:
 398               	.LBB328:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 399               		.loc 4 70 0
 400 015e 5FBF      		out __SREG__,r21
 401               		.loc 4 71 0
 402               	.LBE328:
 403               	.LBE327:
 404               	.LBE322:
 405               	.LBE321:
 406               	.LBB365:
 407               	.LBB366:
 314:usb/usb.h     **** 	}
 315:usb/usb.h     **** }
 316:usb/usb.h     **** 
 317:usb/usb.h     **** inline void USB_Task(void) ATTR_ALWAYS_INLINE;
 318:usb/usb.h     **** inline void USB_Task(void){
 319:usb/usb.h     **** 	// Read once to prevent race condition where SETUP packet is interpreted as OUT
 320:usb/usb.h     **** 	uint8_t status = endpoints[0].out.STATUS;
 408               		.loc 6 320 0
 409 0160 8091 0000 		lds r24,endpoints
 410               	.LVL14:
 321:usb/usb.h     **** 
 322:usb/usb.h     **** 	if (status & USB_EP_SETUP_bm){
 411               		.loc 6 322 0
 412 0164 84FD      		sbrc r24,4
 413 0166 00C0      		rjmp .L50
 414               	.L39:
 323:usb/usb.h     **** 		if (!USB_HandleSetup()){
 324:usb/usb.h     **** 			endpoints[0].out.CTRL |= USB_EP_STALL_bm;
 325:usb/usb.h     **** 			endpoints[0].in.CTRL |= USB_EP_STALL_bm; 
 326:usb/usb.h     **** 		}
 327:usb/usb.h     **** 		USB_ep0_enableOut();
 328:usb/usb.h     **** 	}else if(status & USB_EP_TRNCOMPL0_bm){
 415               		.loc 6 328 0
 416 0168 85FD      		sbrc r24,5
 417 016a 00C0      		rjmp .L51
 418               	.LVL15:
 419               	.L29:
 420               	/* epilogue start */
 421               	.LBE366:
 422               	.LBE365:
  58:TakkTile.h    **** 	usb_pipe_handle(&ep_in);
  59:TakkTile.h    **** 	USB_Task();
  60:TakkTile.h    **** }
 423               		.loc 2 60 0
 424 016c FF91      		pop r31
 425 016e EF91      		pop r30
 426 0170 BF91      		pop r27
 427 0172 AF91      		pop r26
 428 0174 9F91      		pop r25
 429 0176 8F91      		pop r24
 430 0178 7F91      		pop r23
 431 017a 6F91      		pop r22
 432 017c 5F91      		pop r21
 433 017e 4F91      		pop r20
 434 0180 3F91      		pop r19
 435 0182 2F91      		pop r18
 436 0184 0F91      		pop r16
 437 0186 0F90      		pop r0
 438 0188 0FBE      		out __SREG__,r0
 439 018a 0F90      		pop r0
 440 018c 1F90      		pop r1
 441 018e 1895      		reti
 442               	.LVL16:
 443               	.L49:
 444               	.LBB371:
 445               	.LBB362:
 446               	.LBB330:
 447               	.LBB331:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 448               		.loc 5 51 0
 449 0190 4091 0000 		lds r20,ep_in_pipe_data+4
 450               	.LBE331:
 451               	.LBE330:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 452               		.loc 3 83 0
 453 0194 1416      		cp __zero_reg__,r20
 454 0196 04F0      		brlt .+2
 455 0198 00C0      		rjmp .L31
 456               	.LBB332:
 457               	.LBB333:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 458               		.loc 5 62 0
 459 019a 8091 0000 		lds r24,ep_in_pipe_data
 460 019e 9091 0000 		lds r25,ep_in_pipe_data+1
 461               	.LVL17:
 462               	.LBE333:
 463               	.LBE332:
 464               	.LBB334:
 465               	.LBB335:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 466               		.loc 3 68 0
 467 01a2 3091 0000 		lds r19,ep_in_data
 468               	.LVL18:
 469               	.LBE335:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 470               		.loc 3 69 0
 471 01a6 21E0      		ldi r18,lo8(1)
 472 01a8 2327      		eor r18,r19
 473               	.LBB340:
 474 01aa 2093 0000 		sts ep_in_data,r18
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 475               		.loc 3 72 0
 476 01ae 3323      		tst r19
 477 01b0 01F0      		breq .L52
 478               	.LVL19:
 479               	.LBB336:
 480               	.LBB337:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 481               		.loc 6 168 0
 482 01b2 8093 0000 		sts endpoints+20,r24
 483 01b6 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 484               		.loc 6 169 0
 485 01ba 20E4      		ldi r18,lo8(64)
 486 01bc 30E0      		ldi r19,0
 487 01be 2093 0000 		sts endpoints+18,r18
 488 01c2 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 489               		.loc 6 176 0
 490               	/* #APP */
 491               	 ;  176 "usb/usb.h" 1
 492 01c6 04E1      		ldi r16, 20
 493 01c8 0693      		.dc.w 0x9306
 494               		
 495               	 ;  0 "" 2
 496               	.LVL20:
 497               	/* #NOAPP */
 498               	.L33:
 499               	.LBE337:
 500               	.LBE336:
 501               	.LBE340:
 502               	.LBE334:
 503               	.LBB342:
 504               	.LBB343:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 505               		.loc 5 72 0
 506 01ca 4150      		subi r20,lo8(-(-1))
 507 01cc 4093 0000 		sts ep_in_pipe_data+4,r20
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 508               		.loc 5 73 0
 509 01d0 805C      		subi r24,-64
 510 01d2 9F4F      		sbci r25,-1
 511               	.LVL21:
 512 01d4 8093 0000 		sts ep_in_pipe_data,r24
 513 01d8 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 514               		.loc 5 75 0
 515 01dc 8050      		subi r24,lo8(ep_in_pipe_buffer+512)
 516 01de 9040      		sbci r25,hi8(ep_in_pipe_buffer+512)
 517 01e0 01F0      		breq .+2
 518 01e2 00C0      		rjmp .L30
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 519               		.loc 5 76 0
 520 01e4 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 521 01e6 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 522 01e8 8093 0000 		sts ep_in_pipe_data,r24
 523 01ec 9093 0000 		sts ep_in_pipe_data+1,r25
 524               	.LBE343:
 525               	.LBE342:
 526               	.LBB344:
 527               	.LBB329:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 528               		.loc 4 70 0
 529 01f0 5FBF      		out __SREG__,r21
 530               		.loc 4 71 0
 531               	.LBE329:
 532               	.LBE344:
 533               	.LBE362:
 534               	.LBE371:
 535               	.LBB372:
 536               	.LBB369:
 320:usb/usb.h     **** 	uint8_t status = endpoints[0].out.STATUS;
 537               		.loc 6 320 0
 538 01f2 8091 0000 		lds r24,endpoints
 539               	.LVL22:
 322:usb/usb.h     **** 	if (status & USB_EP_SETUP_bm){
 540               		.loc 6 322 0
 541 01f6 84FF      		sbrs r24,4
 542 01f8 00C0      		rjmp .L39
 543               	.LVL23:
 544               	.L50:
 323:usb/usb.h     **** 		if (!USB_HandleSetup()){
 545               		.loc 6 323 0
 546 01fa 0E94 0000 		call USB_HandleSetup
 547               	.LVL24:
 548 01fe 8111      		cpse r24,__zero_reg__
 549 0200 00C0      		rjmp .L48
 324:usb/usb.h     **** 			endpoints[0].out.CTRL |= USB_EP_STALL_bm;
 550               		.loc 6 324 0
 551 0202 8091 0000 		lds r24,endpoints+1
 552 0206 8460      		ori r24,lo8(4)
 553 0208 8093 0000 		sts endpoints+1,r24
 325:usb/usb.h     **** 			endpoints[0].in.CTRL |= USB_EP_STALL_bm; 
 554               		.loc 6 325 0
 555 020c 8091 0000 		lds r24,endpoints+9
 556 0210 8460      		ori r24,lo8(4)
 557 0212 8093 0000 		sts endpoints+9,r24
 558 0216 00C0      		rjmp .L48
 559               	.LVL25:
 560               	.L52:
 561               	.LBE369:
 562               	.LBE372:
 563               	.LBB373:
 564               	.LBB363:
 565               	.LBB345:
 566               	.LBB341:
 567               	.LBB338:
 568               	.LBB339:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 569               		.loc 6 168 0
 570 0218 8093 0000 		sts endpoints+28,r24
 571 021c 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 572               		.loc 6 169 0
 573 0220 20E4      		ldi r18,lo8(64)
 574 0222 30E0      		ldi r19,0
 575 0224 2093 0000 		sts endpoints+26,r18
 576 0228 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 577               		.loc 6 174 0
 578               	/* #APP */
 579               	 ;  174 "usb/usb.h" 1
 580 022c 02E2      		ldi r16, 34
 581 022e 0693      		.dc.w 0x9306
 582               		
 583               	 ;  0 "" 2
 584               	/* #NOAPP */
 585 0230 00C0      		rjmp .L33
 586               	.LVL26:
 587               	.L51:
 588               	.LBE339:
 589               	.LBE338:
 590               	.LBE341:
 591               	.LBE345:
 592               	.LBE363:
 593               	.LBE373:
 594               	.LBB374:
 595               	.LBB370:
 329:usb/usb.h     **** 		EVENT_USB_Device_ControlOUT((uint8_t *) ep0_buf_out, endpoints[0].out.CNT);
 596               		.loc 6 329 0
 597 0232 6091 0000 		lds r22,endpoints+2
 598 0236 7091 0000 		lds r23,endpoints+2+1
 599 023a 80E0      		ldi r24,lo8(ep0_buf_out)
 600 023c 90E0      		ldi r25,hi8(ep0_buf_out)
 601               	.LVL27:
 602 023e 0E94 0000 		call EVENT_USB_Device_ControlOUT
 603               	.LVL28:
 604               	.L48:
 605               	.LBB367:
 606               	.LBB368:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 607               		.loc 6 280 0
 608 0242 E0E0      		ldi r30,lo8(endpoints)
 609 0244 F0E0      		ldi r31,hi8(endpoints)
 610               	/* #APP */
 611               	 ;  280 "usb/usb.h" 1
 612 0246 02E7      		ldi r16, 114
 613 0248 0693      		.dc.w 0x9306
 614               		
 615               	 ;  0 "" 2
 616               	/* #NOAPP */
 617 024a 00C0      		rjmp .L29
 618               	.LVL29:
 619               	.L31:
 620               	.LBE368:
 621               	.LBE367:
 622               	.LBE370:
 623               	.LBE374:
 624               	.LBB375:
 625               	.LBB364:
  84:usb/usb_pipe.h **** 					_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->pipe->size);
  85:usb/usb_pipe.h **** 					pipe_done_read(p->pipe);
  86:usb/usb_pipe.h **** 				}else if (p->features & PIPE_ENABLE_FLUSH){
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 626               		.loc 3 87 0
 627 024c 2091 0000 		lds r18,ep_in_data+1
 628 0250 2130      		cpi r18,lo8(1)
 629 0252 01F0      		breq .L53
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
  89:usb/usb_pipe.h **** 						// Send short packet
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 630               		.loc 3 91 0
 631 0254 2230      		cpi r18,lo8(2)
 632 0256 01F0      		breq .+2
 633 0258 00C0      		rjmp .L30
 634               	.LVL30:
 635               	.LBB346:
 636               	.LBB347:
 637               	.LBB348:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 638               		.loc 6 228 0
 639 025a 8091 0000 		lds r24,endpoints+24
 640 025e 8670      		andi r24,lo8(6)
 641               	.LBE348:
 642               	.LBE347:
 643               	.LBE346:
 644               		.loc 3 91 0
 645 0260 8630      		cpi r24,lo8(6)
 646 0262 01F0      		breq .+2
 647 0264 00C0      		rjmp .L30
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 648               		.loc 3 92 0
 649 0266 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 650               		.loc 3 93 0
 651 026a 1092 0000 		sts ep_in_data+2,__zero_reg__
 652 026e 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 653               	.LBB349:
 654               	.LBB350:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 655               		.loc 5 90 0
 656 0272 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 657               		.loc 5 91 0
 658 0276 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 659 0278 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 660 027a 8093 0000 		sts ep_in_pipe_data+2,r24
 661 027e 9093 0000 		sts ep_in_pipe_data+2+1,r25
 662 0282 8093 0000 		sts ep_in_pipe_data,r24
 663 0286 9093 0000 		sts ep_in_pipe_data+1,r25
 664               	.LVL31:
 665 028a 00C0      		rjmp .L30
 666               	.LVL32:
 667               	.L53:
 668               	.LBE350:
 669               	.LBE349:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 670               		.loc 3 88 0
 671 028c 82E0      		ldi r24,lo8(2)
 672 028e 8093 0000 		sts ep_in_data+1,r24
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 673               		.loc 3 90 0
 674 0292 8091 0000 		lds r24,ep_in_data+2
 675 0296 9091 0000 		lds r25,ep_in_data+2+1
 676               	.LBB351:
 677               	.LBB352:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 678               		.loc 5 62 0
 679 029a 6091 0000 		lds r22,ep_in_pipe_data
 680 029e 4091 0000 		lds r20,ep_in_pipe_data+1
 681               	.LVL33:
 682               	.LBE352:
 683               	.LBE351:
 684               	.LBB353:
 685               	.LBB354:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 686               		.loc 3 68 0
 687 02a2 3091 0000 		lds r19,ep_in_data
 688               	.LVL34:
 689               	.LBE354:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 690               		.loc 3 69 0
 691 02a6 2327      		eor r18,r19
 692               	.LBB361:
 693 02a8 2093 0000 		sts ep_in_data,r18
 694               	.LBB355:
 695               	.LBB356:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 696               		.loc 6 168 0
 697 02ac 262F      		mov r18,r22
 698               	.LBE356:
 699               	.LBE355:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 700               		.loc 3 72 0
 701 02ae 3111      		cpse r19,__zero_reg__
 702 02b0 00C0      		rjmp .L37
 703               	.LVL35:
 704               	.LBB358:
 705               	.LBB357:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 706               		.loc 6 168 0
 707 02b2 342F      		mov r19,r20
 708               	.LVL36:
 709 02b4 2093 0000 		sts endpoints+28,r18
 710 02b8 3093 0000 		sts endpoints+28+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 711               		.loc 6 169 0
 712 02bc 8093 0000 		sts endpoints+26,r24
 713 02c0 9093 0000 		sts endpoints+26+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 714               		.loc 6 174 0
 715               	/* #APP */
 716               	 ;  174 "usb/usb.h" 1
 717 02c4 02E2      		ldi r16, 34
 718 02c6 0693      		.dc.w 0x9306
 719               		
 720               	 ;  0 "" 2
 721               	/* #NOAPP */
 722 02c8 00C0      		rjmp .L30
 723               	.LVL37:
 724               	.L37:
 725               	.LBE357:
 726               	.LBE358:
 727               	.LBB359:
 728               	.LBB360:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 729               		.loc 6 168 0
 730 02ca 342F      		mov r19,r20
 731               	.LVL38:
 732 02cc 2093 0000 		sts endpoints+20,r18
 733 02d0 3093 0000 		sts endpoints+20+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 734               		.loc 6 169 0
 735 02d4 8093 0000 		sts endpoints+18,r24
 736 02d8 9093 0000 		sts endpoints+18+1,r25
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 737               		.loc 6 176 0
 738               	/* #APP */
 739               	 ;  176 "usb/usb.h" 1
 740 02dc 04E1      		ldi r16, 20
 741 02de 0693      		.dc.w 0x9306
 742               		
 743               	 ;  0 "" 2
 744               	/* #NOAPP */
 745 02e0 00C0      		rjmp .L30
 746               	.LBE360:
 747               	.LBE359:
 748               	.LBE361:
 749               	.LBE353:
 750               	.LBE364:
 751               	.LBE375:
 752               		.cfi_endproc
 753               	.LFE59:
 755               	.global	botherAddress
 757               	botherAddress:
 758               	.LFB62:
  11:TakkI2C.c     **** uint8_t botherAddress(uint8_t address, bool stop){
 759               		.loc 1 11 0
 760               		.cfi_startproc
 761               	.LVL39:
 762               	/* prologue: function */
 763               	/* frame size = 0 */
 764               	/* stack size = 0 */
 765               	.L__stack_usage = 0
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 766               		.loc 1 17 0
 767 02e2 9091 8204 		lds r25,1154
 768 02e6 9260      		ori r25,lo8(2)
 769 02e8 9093 8204 		sts 1154,r25
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 770               		.loc 1 19 0
 771 02ec 8093 8604 		sts 1158,r24
  21:TakkI2C.c     **** 	if (address & 1) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 772               		.loc 1 21 0
 773 02f0 80FF      		sbrs r24,0
 774 02f2 00C0      		rjmp .L66
 775               	.LVL40:
 776               	.L65:
  21:TakkI2C.c     **** 	if (address & 1) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 777               		.loc 1 21 0 is_stmt 0 discriminator 1
 778 02f4 8091 8404 		lds r24,1156
 779 02f8 87FF      		sbrs r24,7
 780 02fa 00C0      		rjmp .L65
 781               	.L57:
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 782               		.loc 1 25 0 is_stmt 1
 783 02fc 6623      		tst r22
 784 02fe 01F0      		breq .L58
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 785               		.loc 1 25 0 is_stmt 0 discriminator 1
 786 0300 8091 8304 		lds r24,1155
 787 0304 8360      		ori r24,lo8(3)
 788 0306 8093 8304 		sts 1155,r24
 789               	.L58:
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 790               		.loc 1 27 0 is_stmt 1
 791 030a 8091 8404 		lds r24,1156
 792 030e 84FB      		bst r24,4
 793 0310 2227      		clr r18
 794 0312 20F9      		bld r18,0
 795 0314 30E0      		ldi r19,0
 796 0316 81E0      		ldi r24,1
 797 0318 2827      		eor r18,r24
 798               		.loc 1 28 0
 799 031a 822F      		mov r24,r18
 800 031c 0895      		ret
 801               	.L66:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 802               		.loc 1 23 0 discriminator 1
 803 031e 8091 8404 		lds r24,1156
 804 0322 86FD      		sbrc r24,6
 805 0324 00C0      		rjmp .L57
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 806               		.loc 1 23 0 is_stmt 0
 807 0326 8091 8404 		lds r24,1156
 808 032a 86FF      		sbrs r24,6
 809 032c 00C0      		rjmp .L66
 810 032e 00C0      		rjmp .L57
 811               		.cfi_endproc
 812               	.LFE62:
 814               	.global	getCalibrationData
 816               	getCalibrationData:
 817               	.LFB64:
  29:TakkI2C.c     **** 
  30:TakkI2C.c     **** inline void startConversion(){
  31:TakkI2C.c     **** 	// Initiates the analog-to-digital conversion of pressure and temperature
  32:TakkI2C.c     **** 	// on all MPL115A2 sensors on all attached rows.
  33:TakkI2C.c     **** 		
  34:TakkI2C.c     **** 	// enable all MPL115A2 by writing to 0x0C
  35:TakkI2C.c     **** 	uint8_t ACK = botherAddress(calcTinyAddr(0, 6), 1);
  36:TakkI2C.c     **** 	// write address byte of MPL115A2
  37:TakkI2C.c     **** 	botherAddress(0xC0, 0);
  38:TakkI2C.c     **** 	// write 0x01 to 0x12 - start conversion of pressure & temperature
  39:TakkI2C.c     **** 	TWIC.MASTER.DATA = 0x12;
  40:TakkI2C.c     **** 	while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
  41:TakkI2C.c     **** 	TWIC.MASTER.DATA = 0x01;
  42:TakkI2C.c     **** 	while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
  43:TakkI2C.c     **** 	// end transaction
  44:TakkI2C.c     **** 	TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
  45:TakkI2C.c     **** 	// if you got an ACK on enable, disable all the MPL115A2s
  46:TakkI2C.c     **** 	if (ACK == 1) botherAddress(calcTinyAddr(0, 6)^1, 1);
  47:TakkI2C.c     **** 
  48:TakkI2C.c     **** }
  49:TakkI2C.c     **** 
  50:TakkI2C.c     **** void getCalibrationData(uint8_t cell){
 818               		.loc 1 50 0 is_stmt 1
 819               		.cfi_startproc
 820               	.LVL41:
 821               	/* prologue: function */
 822               	/* frame size = 0 */
 823               	/* stack size = 0 */
 824               	.L__stack_usage = 0
  51:TakkI2C.c     **** 	// Iterate through all rows and all columns. If that cell is alive,
  52:TakkI2C.c     **** 	// read 8 calibration bytes from 0x04 into calibrationData.
  53:TakkI2C.c     **** 	TWIC.MASTER.CTRLC &= ~TWI_MASTER_ACKACT_bm;
 825               		.loc 1 53 0
 826 0330 9091 8304 		lds r25,1155
 827 0334 9B7F      		andi r25,lo8(-5)
 828 0336 9093 8304 		sts 1155,r25
  54:TakkI2C.c     **** 	TWIC.MASTER.CTRLB = TWI_MASTER_SMEN_bm;
 829               		.loc 1 54 0
 830 033a 91E0      		ldi r25,lo8(1)
 831 033c 9093 8204 		sts 1154,r25
  55:TakkI2C.c     **** 	if ( aliveCells[cell] == 0xFF ){
 832               		.loc 1 55 0
 833 0340 E82F      		mov r30,r24
 834 0342 F0E0      		ldi r31,0
 835 0344 E050      		subi r30,lo8(-(aliveCells))
 836 0346 F040      		sbci r31,hi8(-(aliveCells))
 837 0348 9081      		ld r25,Z
 838 034a 9F3F      		cpi r25,lo8(-1)
 839 034c 01F0      		breq .L105
  56:TakkI2C.c     **** 		// attiny address formula
  57:TakkI2C.c     **** 		uint8_t tinyAddr = calcTinyAddrFlat(cell); 
  58:TakkI2C.c     **** 		// enable cell
  59:TakkI2C.c     **** 		botherAddress(tinyAddr, 1);
  60:TakkI2C.c     **** 		// start write to MPL115A2 
  61:TakkI2C.c     **** 		botherAddress(0xC0, 0);
  62:TakkI2C.c     **** 		TWIC.MASTER.CTRLB = TWI_MASTER_SMEN_bm; 
  63:TakkI2C.c     **** 		// set start address to 0
  64:TakkI2C.c     **** 		TWIC.MASTER.DATA = 0x04;
  65:TakkI2C.c     **** 		while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
  66:TakkI2C.c     **** 		// end transaction
  67:TakkI2C.c     **** 		TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
  68:TakkI2C.c     **** 		// start read from MPL115A2
  69:TakkI2C.c     **** 		TWIC.MASTER.ADDR = 0xC1;
  70:TakkI2C.c     **** 		while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
  71:TakkI2C.c     **** 		for (uint8_t byteCt = 0; byteCt < 8; byteCt++){
  72:TakkI2C.c     **** 			ep0_buf_in[byteCt] = TWIC.MASTER.DATA;
  73:TakkI2C.c     **** 			// if transaction isn't over, wait for ACK
  74:TakkI2C.c     **** 			if (byteCt < 7) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
  75:TakkI2C.c     **** 			// if transaction is almost over, set next byte to NACK
  76:TakkI2C.c     **** 			if (byteCt == 6) TWIC.MASTER.CTRLC |= TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
  77:TakkI2C.c     **** 			}
  78:TakkI2C.c     **** 		botherAddress(tinyAddr^1, 1);
  79:TakkI2C.c     **** 	}
  80:TakkI2C.c     **** 	else TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 840               		.loc 1 80 0
 841 034e 8091 8304 		lds r24,1155
 842               	.LVL42:
 843 0352 8360      		ori r24,lo8(3)
 844 0354 8093 8304 		sts 1155,r24
 845 0358 0895      		ret
 846               	.LVL43:
 847               	.L105:
 848               	.LBB386:
 849               	.LBB387:
 850               	.LBB388:
   9:TakkI2C.c     **** inline uint8_t calcTinyAddrFlat(uint8_t cell) { return (((cell/5)&0x0F) << 4 | ((cell%5)&0x07) << 1
 851               		.loc 1 9 0
 852 035a 2DEC      		ldi r18,lo8(-51)
 853 035c 829F      		mul r24,r18
 854 035e 212D      		mov r18,r1
 855 0360 1124      		clr __zero_reg__
 856 0362 2695      		lsr r18
 857 0364 2695      		lsr r18
 858 0366 922F      		mov r25,r18
 859 0368 990F      		lsl r25
 860 036a 990F      		lsl r25
 861 036c 920F      		add r25,r18
 862 036e 891B      		sub r24,r25
 863               	.LVL44:
 864 0370 880F      		lsl r24
 865 0372 90E1      		ldi r25,lo8(16)
 866 0374 299F      		mul r18,r25
 867 0376 9001      		movw r18,r0
 868 0378 1124      		clr __zero_reg__
 869 037a 822B      		or r24,r18
 870               	.LVL45:
 871               	.LBE388:
 872               	.LBE387:
 873               	.LBB389:
 874               	.LBB390:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 875               		.loc 1 17 0
 876 037c 9091 8204 		lds r25,1154
 877 0380 9260      		ori r25,lo8(2)
 878 0382 9093 8204 		sts 1154,r25
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 879               		.loc 1 19 0
 880 0386 8093 8604 		sts 1158,r24
 881               	.L75:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 882               		.loc 1 23 0
 883 038a 9091 8404 		lds r25,1156
 884 038e 96FF      		sbrs r25,6
 885 0390 00C0      		rjmp .L75
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 886               		.loc 1 25 0
 887 0392 9091 8304 		lds r25,1155
 888 0396 9360      		ori r25,lo8(3)
 889 0398 9093 8304 		sts 1155,r25
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 890               		.loc 1 27 0
 891 039c 9091 8404 		lds r25,1156
 892               	.LVL46:
 893               	.LBE390:
 894               	.LBE389:
 895               	.LBB391:
 896               	.LBB392:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 897               		.loc 1 17 0
 898 03a0 9091 8204 		lds r25,1154
 899 03a4 9260      		ori r25,lo8(2)
 900 03a6 9093 8204 		sts 1154,r25
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 901               		.loc 1 19 0
 902 03aa 90EC      		ldi r25,lo8(-64)
 903 03ac 9093 8604 		sts 1158,r25
 904               	.L76:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 905               		.loc 1 23 0
 906 03b0 9091 8404 		lds r25,1156
 907 03b4 96FF      		sbrs r25,6
 908 03b6 00C0      		rjmp .L76
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 909               		.loc 1 27 0
 910 03b8 9091 8404 		lds r25,1156
 911               	.LBE392:
 912               	.LBE391:
  62:TakkI2C.c     **** 		TWIC.MASTER.CTRLB = TWI_MASTER_SMEN_bm; 
 913               		.loc 1 62 0
 914 03bc 91E0      		ldi r25,lo8(1)
 915 03be 9093 8204 		sts 1154,r25
  64:TakkI2C.c     **** 		TWIC.MASTER.DATA = 0x04;
 916               		.loc 1 64 0
 917 03c2 94E0      		ldi r25,lo8(4)
 918 03c4 9093 8704 		sts 1159,r25
 919               	.L77:
  65:TakkI2C.c     **** 		while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 920               		.loc 1 65 0 discriminator 1
 921 03c8 9091 8404 		lds r25,1156
 922 03cc 96FF      		sbrs r25,6
 923 03ce 00C0      		rjmp .L77
  67:TakkI2C.c     **** 		TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 924               		.loc 1 67 0
 925 03d0 9091 8304 		lds r25,1155
 926 03d4 9360      		ori r25,lo8(3)
 927 03d6 9093 8304 		sts 1155,r25
  69:TakkI2C.c     **** 		TWIC.MASTER.ADDR = 0xC1;
 928               		.loc 1 69 0
 929 03da 91EC      		ldi r25,lo8(-63)
 930 03dc 9093 8604 		sts 1158,r25
 931               	.L78:
  70:TakkI2C.c     **** 		while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 932               		.loc 1 70 0 discriminator 1
 933 03e0 9091 8404 		lds r25,1156
 934 03e4 97FF      		sbrs r25,7
 935 03e6 00C0      		rjmp .L78
 936               	.LVL47:
 937               	.LBB393:
  72:TakkI2C.c     **** 			ep0_buf_in[byteCt] = TWIC.MASTER.DATA;
 938               		.loc 1 72 0
 939 03e8 9091 8704 		lds r25,1159
 940 03ec 9093 0000 		sts ep0_buf_in,r25
 941 03f0 20E0      		ldi r18,0
 942               	.LVL48:
 943               	.L103:
  74:TakkI2C.c     **** 			if (byteCt < 7) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 944               		.loc 1 74 0 discriminator 1
 945 03f2 9091 8404 		lds r25,1156
 946 03f6 97FF      		sbrs r25,7
 947 03f8 00C0      		rjmp .L103
  76:TakkI2C.c     **** 			if (byteCt == 6) TWIC.MASTER.CTRLC |= TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
 948               		.loc 1 76 0
 949 03fa 2630      		cpi r18,lo8(6)
 950 03fc 01F4      		brne .L82
  76:TakkI2C.c     **** 			if (byteCt == 6) TWIC.MASTER.CTRLC |= TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
 951               		.loc 1 76 0 is_stmt 0 discriminator 1
 952 03fe 9091 8304 		lds r25,1155
 953 0402 9760      		ori r25,lo8(7)
 954 0404 9093 8304 		sts 1155,r25
 955               	.LVL49:
  72:TakkI2C.c     **** 			ep0_buf_in[byteCt] = TWIC.MASTER.DATA;
 956               		.loc 1 72 0 is_stmt 1 discriminator 1
 957 0408 9091 8704 		lds r25,1159
 958 040c 9093 0000 		sts ep0_buf_in+7,r25
 959               	.LVL50:
 960               	.L83:
 961               	.LBE393:
  78:TakkI2C.c     **** 		botherAddress(tinyAddr^1, 1);
 962               		.loc 1 78 0
 963 0410 91E0      		ldi r25,lo8(1)
 964 0412 9827      		eor r25,r24
 965               	.LVL51:
 966               	.LBB394:
 967               	.LBB395:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 968               		.loc 1 17 0
 969 0414 8091 8204 		lds r24,1154
 970               	.LVL52:
 971 0418 8260      		ori r24,lo8(2)
 972 041a 8093 8204 		sts 1154,r24
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 973               		.loc 1 19 0
 974 041e 9093 8604 		sts 1158,r25
 975               	.L81:
  21:TakkI2C.c     **** 	if (address & 1) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 976               		.loc 1 21 0
 977 0422 8091 8404 		lds r24,1156
 978 0426 87FF      		sbrs r24,7
 979 0428 00C0      		rjmp .L81
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 980               		.loc 1 25 0
 981 042a 8091 8304 		lds r24,1155
 982 042e 8360      		ori r24,lo8(3)
 983 0430 8093 8304 		sts 1155,r24
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 984               		.loc 1 27 0
 985 0434 8091 8404 		lds r24,1156
 986 0438 0895      		ret
 987               	.LVL53:
 988               	.L82:
 989               	.LBE395:
 990               	.LBE394:
 991               	.LBB396:
  71:TakkI2C.c     **** 		for (uint8_t byteCt = 0; byteCt < 8; byteCt++){
 992               		.loc 1 71 0
 993 043a 2F5F      		subi r18,lo8(-(1))
 994               	.LVL54:
 995 043c 2830      		cpi r18,lo8(8)
 996 043e 01F0      		breq .L83
  72:TakkI2C.c     **** 			ep0_buf_in[byteCt] = TWIC.MASTER.DATA;
 997               		.loc 1 72 0
 998 0440 9091 8704 		lds r25,1159
 999 0444 E22F      		mov r30,r18
 1000 0446 F0E0      		ldi r31,0
 1001 0448 E050      		subi r30,lo8(-(ep0_buf_in))
 1002 044a F040      		sbci r31,hi8(-(ep0_buf_in))
 1003 044c 9083      		st Z,r25
  74:TakkI2C.c     **** 			if (byteCt < 7) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 1004               		.loc 1 74 0
 1005 044e 2730      		cpi r18,lo8(7)
 1006 0450 01F4      		brne .L103
 1007 0452 00C0      		rjmp .L83
 1008               	.LBE396:
 1009               	.LBE386:
 1010               		.cfi_endproc
 1011               	.LFE64:
 1013               	.global	getSensorData
 1015               	getSensorData:
 1016               	.LFB65:
  81:TakkI2C.c     **** }
  82:TakkI2C.c     **** 
  83:TakkI2C.c     **** void getSensorData(void){
 1017               		.loc 1 83 0
 1018               		.cfi_startproc
 1019 0454 EF92      		push r14
 1020               	.LCFI29:
 1021               		.cfi_def_cfa_offset 3
 1022               		.cfi_offset 14, -2
 1023 0456 FF92      		push r15
 1024               	.LCFI30:
 1025               		.cfi_def_cfa_offset 4
 1026               		.cfi_offset 15, -3
 1027 0458 0F93      		push r16
 1028               	.LCFI31:
 1029               		.cfi_def_cfa_offset 5
 1030               		.cfi_offset 16, -4
 1031 045a 1F93      		push r17
 1032               	.LCFI32:
 1033               		.cfi_def_cfa_offset 6
 1034               		.cfi_offset 17, -5
 1035 045c CF93      		push r28
 1036               	.LCFI33:
 1037               		.cfi_def_cfa_offset 7
 1038               		.cfi_offset 28, -6
 1039 045e DF93      		push r29
 1040               	.LCFI34:
 1041               		.cfi_def_cfa_offset 8
 1042               		.cfi_offset 29, -7
 1043               	/* prologue: function */
 1044               	/* frame size = 0 */
 1045               	/* stack size = 6 */
 1046               	.L__stack_usage = 6
 1047               	.LVL55:
 1048 0460 E0E0      		ldi r30,lo8(aliveCells)
 1049 0462 F0E0      		ldi r31,hi8(aliveCells)
 1050               		.loc 1 83 0
 1051 0464 80E0      		ldi r24,0
 1052 0466 90E0      		ldi r25,0
 1053               	.LBB618:
  84:TakkI2C.c     **** 	/* Iterate through all cells. If that cell is alive,
  85:TakkI2C.c     **** 	read four data bytes from memory address 0x00 into sensorData buffer.
  86:TakkI2C.c     **** 	If SLAVE, send sensorData buffer via DMA.
  87:TakkI2C.c     **** 	If MASTER, send sensorData and sensorDataPrime via USB. */
  88:TakkI2C.c     **** 	uint8_t datum = 0x00;
  89:TakkI2C.c     **** 	for (uint8_t cell = 0; cell < 40; cell++) {
  90:TakkI2C.c     **** 		TWIC.MASTER.CTRLC &= ~TWI_MASTER_ACKACT_bm;
  91:TakkI2C.c     **** 		TWIC.MASTER.CTRLB = TWI_MASTER_SMEN_bm;
 1054               		.loc 1 91 0
 1055 0468 51E0      		ldi r21,lo8(1)
 1056               	.LBB619:
 1057               	.LBB620:
 1058               	.LBB621:
   9:TakkI2C.c     **** inline uint8_t calcTinyAddrFlat(uint8_t cell) { return (((cell/5)&0x0F) << 4 | ((cell%5)&0x07) << 1
 1059               		.loc 1 9 0
 1060 046a 1DEC      		ldi r17,lo8(-51)
 1061               	.LBE621:
 1062               	.LBE620:
 1063               	.LBB623:
 1064               	.LBB624:
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 1065               		.loc 1 19 0
 1066 046c 70EC      		ldi r23,lo8(-64)
 1067               	.LBE624:
 1068               	.LBE623:
  92:TakkI2C.c     **** 		// attiny address formula
  93:TakkI2C.c     **** 		if ( aliveCells[cell] == 0xFF ) { 
  94:TakkI2C.c     **** 			uint8_t tinyAddr = calcTinyAddrFlat(cell); 
  95:TakkI2C.c     **** 			// enable cell
  96:TakkI2C.c     **** 			botherAddress(tinyAddr, 1);
  97:TakkI2C.c     **** 			// start write to MPL115A2
  98:TakkI2C.c     **** 			botherAddress(0xC0, 0);
  99:TakkI2C.c     **** 			TWIC.MASTER.CTRLB = TWI_MASTER_SMEN_bm;	 
 100:TakkI2C.c     **** 			// set start address to 0
 101:TakkI2C.c     **** 			TWIC.MASTER.DATA = 0x00;
 102:TakkI2C.c     **** 			while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 103:TakkI2C.c     **** 			// end transaction
 104:TakkI2C.c     **** 			TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 105:TakkI2C.c     **** 			// start read from MPL115A2
 106:TakkI2C.c     **** 			TWIC.MASTER.ADDR = 0xC1;
 1069               		.loc 1 106 0
 1070 046e 61EC      		ldi r22,lo8(-63)
 1071 0470 00C0      		rjmp .L119
 1072               	.LVL56:
 1073               	.L107:
 1074               	.LBE619:
 107:TakkI2C.c     **** 			while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 108:TakkI2C.c     **** 			// clock out four bytes
 109:TakkI2C.c     **** 			for (uint8_t byteCt = 0; byteCt < 4; byteCt++){
 110:TakkI2C.c     **** 				datum = TWIC.MASTER.DATA;
 111:TakkI2C.c     **** 				sensorData[(cell<<2) + byteCt] = datum;
 112:TakkI2C.c     **** 				// if transaction isn't over, wait for ACK
 113:TakkI2C.c     **** 				if (byteCt < 3) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 114:TakkI2C.c     **** 				// if transaction is almost over, set next byte to NACK
 115:TakkI2C.c     **** 				if (byteCt == 2) TWIC.MASTER.CTRLC |= TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
 116:TakkI2C.c     **** 			}
 117:TakkI2C.c     **** 		botherAddress(tinyAddr^1, 1);
 118:TakkI2C.c     **** 		}
 119:TakkI2C.c     **** 		else TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 1075               		.loc 1 119 0
 1076 0472 2091 8304 		lds r18,1155
 1077 0476 2360      		ori r18,lo8(3)
 1078 0478 2093 8304 		sts 1155,r18
 1079 047c 0196      		adiw r24,1
  89:TakkI2C.c     **** 	for (uint8_t cell = 0; cell < 40; cell++) {
 1080               		.loc 1 89 0
 1081 047e 8832      		cpi r24,40
 1082 0480 9105      		cpc r25,__zero_reg__
 1083 0482 01F4      		brne .+2
 1084 0484 00C0      		rjmp .L219
 1085               	.L119:
 1086 0486 482F      		mov r20,r24
  90:TakkI2C.c     **** 		TWIC.MASTER.CTRLC &= ~TWI_MASTER_ACKACT_bm;
 1087               		.loc 1 90 0
 1088 0488 2091 8304 		lds r18,1155
 1089 048c 2B7F      		andi r18,lo8(-5)
 1090 048e 2093 8304 		sts 1155,r18
  91:TakkI2C.c     **** 		TWIC.MASTER.CTRLB = TWI_MASTER_SMEN_bm;
 1091               		.loc 1 91 0
 1092 0492 5093 8204 		sts 1154,r21
  93:TakkI2C.c     **** 		if ( aliveCells[cell] == 0xFF ) { 
 1093               		.loc 1 93 0
 1094 0496 2191      		ld r18,Z+
 1095 0498 2F3F      		cpi r18,lo8(-1)
 1096 049a 01F4      		brne .L107
 1097               	.LVL57:
 1098               	.LBB634:
 1099               	.LBB626:
 1100               	.LBB622:
   9:TakkI2C.c     **** inline uint8_t calcTinyAddrFlat(uint8_t cell) { return (((cell/5)&0x0F) << 4 | ((cell%5)&0x07) << 1
 1101               		.loc 1 9 0
 1102 049c 819F      		mul r24,r17
 1103 049e 212D      		mov r18,r1
 1104 04a0 1124      		clr __zero_reg__
 1105 04a2 2695      		lsr r18
 1106 04a4 2695      		lsr r18
 1107 04a6 322F      		mov r19,r18
 1108 04a8 330F      		lsl r19
 1109 04aa 330F      		lsl r19
 1110 04ac 320F      		add r19,r18
 1111 04ae 431B      		sub r20,r19
 1112               	.LVL58:
 1113 04b0 440F      		lsl r20
 1114 04b2 A0E1      		ldi r26,lo8(16)
 1115 04b4 2A9F      		mul r18,r26
 1116 04b6 9001      		movw r18,r0
 1117 04b8 1124      		clr __zero_reg__
 1118 04ba 422B      		or r20,r18
 1119               	.LVL59:
 1120               	.LBE622:
 1121               	.LBE626:
 1122               	.LBB627:
 1123               	.LBB628:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 1124               		.loc 1 17 0
 1125 04bc 2091 8204 		lds r18,1154
 1126 04c0 2260      		ori r18,lo8(2)
 1127 04c2 2093 8204 		sts 1154,r18
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 1128               		.loc 1 19 0
 1129 04c6 4093 8604 		sts 1158,r20
 1130               	.L108:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 1131               		.loc 1 23 0
 1132 04ca 2091 8404 		lds r18,1156
 1133 04ce 26FF      		sbrs r18,6
 1134 04d0 00C0      		rjmp .L108
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 1135               		.loc 1 25 0
 1136 04d2 2091 8304 		lds r18,1155
 1137 04d6 2360      		ori r18,lo8(3)
 1138 04d8 2093 8304 		sts 1155,r18
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 1139               		.loc 1 27 0
 1140 04dc 2091 8404 		lds r18,1156
 1141               	.LVL60:
 1142               	.LBE628:
 1143               	.LBE627:
 1144               	.LBB629:
 1145               	.LBB625:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 1146               		.loc 1 17 0
 1147 04e0 2091 8204 		lds r18,1154
 1148 04e4 2260      		ori r18,lo8(2)
 1149 04e6 2093 8204 		sts 1154,r18
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 1150               		.loc 1 19 0
 1151 04ea 7093 8604 		sts 1158,r23
 1152               	.L109:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 1153               		.loc 1 23 0
 1154 04ee 2091 8404 		lds r18,1156
 1155 04f2 26FF      		sbrs r18,6
 1156 04f4 00C0      		rjmp .L109
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 1157               		.loc 1 27 0
 1158 04f6 2091 8404 		lds r18,1156
 1159               	.LBE625:
 1160               	.LBE629:
  99:TakkI2C.c     **** 			TWIC.MASTER.CTRLB = TWI_MASTER_SMEN_bm;	 
 1161               		.loc 1 99 0
 1162 04fa 5093 8204 		sts 1154,r21
 101:TakkI2C.c     **** 			TWIC.MASTER.DATA = 0x00;
 1163               		.loc 1 101 0
 1164 04fe 1092 8704 		sts 1159,__zero_reg__
 1165               	.L110:
 102:TakkI2C.c     **** 			while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 1166               		.loc 1 102 0 discriminator 1
 1167 0502 2091 8404 		lds r18,1156
 1168 0506 26FF      		sbrs r18,6
 1169 0508 00C0      		rjmp .L110
 104:TakkI2C.c     **** 			TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 1170               		.loc 1 104 0
 1171 050a 2091 8304 		lds r18,1155
 1172 050e 2360      		ori r18,lo8(3)
 1173 0510 2093 8304 		sts 1155,r18
 106:TakkI2C.c     **** 			TWIC.MASTER.ADDR = 0xC1;
 1174               		.loc 1 106 0
 1175 0514 6093 8604 		sts 1158,r22
 1176               	.L111:
 107:TakkI2C.c     **** 			while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 1177               		.loc 1 107 0 discriminator 1
 1178 0518 2091 8404 		lds r18,1156
 1179 051c 27FF      		sbrs r18,7
 1180 051e 00C0      		rjmp .L111
 1181               	.LVL61:
 1182               	.LBB630:
 110:TakkI2C.c     **** 				datum = TWIC.MASTER.DATA;
 1183               		.loc 1 110 0
 1184 0520 2091 8704 		lds r18,1159
 1185               	.LVL62:
 111:TakkI2C.c     **** 				sensorData[(cell<<2) + byteCt] = datum;
 1186               		.loc 1 111 0
 1187 0524 DC01      		movw r26,r24
 1188 0526 AA0F      		lsl r26
 1189 0528 BB1F      		rol r27
 1190 052a AA0F      		lsl r26
 1191 052c BB1F      		rol r27
 1192 052e A050      		subi r26,lo8(-(sensorData))
 1193 0530 B040      		sbci r27,hi8(-(sensorData))
 1194 0532 2C93      		st X,r18
 1195 0534 30E0      		ldi r19,0
 1196               	.LVL63:
 1197               	.L214:
 113:TakkI2C.c     **** 				if (byteCt < 3) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 1198               		.loc 1 113 0 discriminator 1
 1199 0536 2091 8404 		lds r18,1156
 1200 053a 27FF      		sbrs r18,7
 1201 053c 00C0      		rjmp .L214
 115:TakkI2C.c     **** 				if (byteCt == 2) TWIC.MASTER.CTRLC |= TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
 1202               		.loc 1 115 0
 1203 053e 3230      		cpi r19,lo8(2)
 1204 0540 01F0      		breq .+2
 1205 0542 00C0      		rjmp .L115
 115:TakkI2C.c     **** 				if (byteCt == 2) TWIC.MASTER.CTRLC |= TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
 1206               		.loc 1 115 0 is_stmt 0 discriminator 1
 1207 0544 2091 8304 		lds r18,1155
 1208 0548 2760      		ori r18,lo8(7)
 1209 054a 2093 8304 		sts 1155,r18
 1210               	.LVL64:
 110:TakkI2C.c     **** 				datum = TWIC.MASTER.DATA;
 1211               		.loc 1 110 0 is_stmt 1 discriminator 1
 1212 054e 2091 8704 		lds r18,1159
 1213               	.LVL65:
 111:TakkI2C.c     **** 				sensorData[(cell<<2) + byteCt] = datum;
 1214               		.loc 1 111 0 discriminator 1
 1215 0552 1396      		adiw r26,3
 1216 0554 2C93      		st X,r18
 1217               	.LVL66:
 1218               	.L116:
 1219               	.LBE630:
 117:TakkI2C.c     **** 		botherAddress(tinyAddr^1, 1);
 1220               		.loc 1 117 0
 1221 0556 4527      		eor r20,r21
 1222               	.LVL67:
 1223               	.LBB631:
 1224               	.LBB632:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 1225               		.loc 1 17 0
 1226 0558 2091 8204 		lds r18,1154
 1227 055c 2260      		ori r18,lo8(2)
 1228 055e 2093 8204 		sts 1154,r18
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 1229               		.loc 1 19 0
 1230 0562 4093 8604 		sts 1158,r20
 1231               	.L114:
  21:TakkI2C.c     **** 	if (address & 1) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 1232               		.loc 1 21 0
 1233 0566 2091 8404 		lds r18,1156
 1234 056a 27FF      		sbrs r18,7
 1235 056c 00C0      		rjmp .L114
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 1236               		.loc 1 25 0
 1237 056e 2091 8304 		lds r18,1155
 1238 0572 2360      		ori r18,lo8(3)
 1239 0574 2093 8304 		sts 1155,r18
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 1240               		.loc 1 27 0
 1241 0578 2091 8404 		lds r18,1156
 1242 057c 0196      		adiw r24,1
 1243               	.LVL68:
 1244               	.LBE632:
 1245               	.LBE631:
 1246               	.LBE634:
  89:TakkI2C.c     **** 	for (uint8_t cell = 0; cell < 40; cell++) {
 1247               		.loc 1 89 0
 1248 057e 8832      		cpi r24,40
 1249 0580 9105      		cpc r25,__zero_reg__
 1250 0582 01F0      		breq .+2
 1251 0584 00C0      		rjmp .L119
 1252               	.LVL69:
 1253               	.L219:
 1254               	.LBE618:
 120:TakkI2C.c     **** 	}
 121:TakkI2C.c     **** 	if (MASTER & ~timeout_or_sampling_no_longer_enabled){
 1255               		.loc 1 121 0
 1256 0586 8091 0000 		lds r24,timeout_or_sampling_no_longer_enabled
 1257 058a 90E0      		ldi r25,0
 1258 058c 8095      		com r24
 1259 058e 9095      		com r25
 1260 0590 2091 0000 		lds r18,MASTER
 1261 0594 30E0      		ldi r19,0
 1262 0596 8223      		and r24,r18
 1263 0598 9323      		and r25,r19
 1264 059a 892B      		or r24,r25
 1265 059c 01F4      		brne .+2
 1266 059e 00C0      		rjmp .L121
 1267 05a0 C0E0      		ldi r28,lo8(sensorData)
 1268 05a2 D0E0      		ldi r29,hi8(sensorData)
 1269 05a4 E0E0      		ldi r30,lo8(endpoints+24)
 1270 05a6 F0E0      		ldi r31,hi8(endpoints+24)
 1271               	.LBB636:
 1272               	.LBB637:
 1273               	.LBB638:
 1274               	.LBB639:
 1275               	.LBB640:
 1276               	.LBB641:
 1277               	.LBB642:
 1278               	.LBB643:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 1279               		.loc 5 57 0
 1280 05a8 16E0      		ldi r17,lo8(6)
 1281               	.LBE643:
 1282               	.LBE642:
 1283               	.LBE641:
 1284               	.LBE640:
 1285               	.LBE639:
 1286               	.LBB654:
 1287               	.LBB655:
 1288               	.LBB656:
 1289               	.LBB657:
 1290               	.LBB658:
 1291               	.LBB659:
 1292               	.LBB660:
 1293               		.loc 5 91 0
 1294 05aa 40E0      		ldi r20,lo8(ep_in_pipe_buffer)
 1295 05ac 50E0      		ldi r21,hi8(ep_in_pipe_buffer)
 1296               	.LBE660:
 1297               	.LBE659:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 1298               		.loc 3 88 0
 1299 05ae 72E0      		ldi r23,lo8(2)
 1300 05b0 E72E      		mov r14,r23
 1301               	.LBB663:
 1302               	.LBB664:
 1303               	.LBB665:
 1304               	.LBB666:
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1305               		.loc 6 169 0
 1306 05b2 20E4      		ldi r18,lo8(64)
 1307 05b4 30E0      		ldi r19,0
 1308               	.L136:
 1309               	.LBE666:
 1310               	.LBE665:
 1311               	.LBE664:
 1312               	.LBE663:
 1313               	.LBE658:
 1314               	.LBE657:
 1315               	.LBE656:
 1316               	.LBE655:
 1317               	.LBE654:
 1318               	.LBE638:
 1319               	.LBE637:
 122:TakkI2C.c     **** 		for (uint8_t i = 0; i < 160; i++) send_byte(sensorData[i]);
 1320               		.loc 1 122 0 discriminator 2
 1321 05b6 7991      		ld r23,Y+
 1322               	.LVL70:
 1323               	.L124:
 1324               	.LBB723:
 1325               	.LBB721:
 1326               	.LBB717:
 1327               	.LBB652:
 1328               	.LBB650:
  94:usb/usb_pipe.h **** 						pipe_reset(p->pipe);
  95:usb/usb_pipe.h **** 					}
  96:usb/usb_pipe.h **** 				}
  97:usb/usb_pipe.h **** 			}
  98:usb/usb_pipe.h **** 		}else{
  99:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep) && pipe_can_write(p->pipe) >= 1){
 100:usb/usb_pipe.h **** 				_usb_pipe_ep_start(p, pipe_write_ptr(p->pipe), p->pipe->size);
 101:usb/usb_pipe.h **** 				pipe_done_write(p->pipe);
 102:usb/usb_pipe.h **** 			}
 103:usb/usb_pipe.h **** 		}
 104:usb/usb_pipe.h **** 	}
 105:usb/usb_pipe.h **** }
 106:usb/usb_pipe.h **** 
 107:usb/usb_pipe.h **** static inline void usb_pipe_flush(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 108:usb/usb_pipe.h **** static inline void usb_pipe_flush(const USB_Pipe* p){
 109:usb/usb_pipe.h **** 	GCC_ASSERT(p->features&PIPE_ENABLE_FLUSH && p->ep&USB_EP_IN);
 110:usb/usb_pipe.h **** 	p->data->flush = 1;
 111:usb/usb_pipe.h **** 	usb_pipe_handle(p);
 112:usb/usb_pipe.h **** }
 113:usb/usb_pipe.h **** 
 114:usb/usb_pipe.h **** static inline bool usb_pipe_flush_done(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 115:usb/usb_pipe.h **** static inline bool usb_pipe_flush_done(const USB_Pipe* p){
 116:usb/usb_pipe.h **** 	GCC_ASSERT(p->features&PIPE_ENABLE_FLUSH);
 117:usb/usb_pipe.h **** 	return p->data->flush;
 118:usb/usb_pipe.h **** }
 119:usb/usb_pipe.h **** 
 120:usb/usb_pipe.h **** static inline bool usb_pipe_can_write(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 121:usb/usb_pipe.h **** static inline bool usb_pipe_can_write(const USB_Pipe* p){
 122:usb/usb_pipe.h **** 	bool r;
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1329               		.loc 3 123 0
 1330 05b8 9FB7      		in r25,__SREG__
 1331               	.LVL71:
 1332               	.LBB645:
 1333               	.LBB646:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 1334               		.loc 4 50 0
 1335               	/* #APP */
 1336               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 1337 05ba F894      		cli
 1338               	 ;  0 "" 2
 1339               	.LVL72:
 1340               	/* #NOAPP */
 1341               	.LBE646:
 1342               	.LBE645:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 1343               		.loc 3 124 0
 1344 05bc 8091 0000 		lds r24,ep_in_data+1
 1345 05c0 8823      		tst r24
 1346 05c2 01F4      		brne .+2
 1347 05c4 00C0      		rjmp .L220
 1348               	.L168:
 125:usb/usb_pipe.h **** 			r = false;
 1349               		.loc 3 125 0
 1350 05c6 80E0      		ldi r24,0
 1351               	.L122:
 1352               	.LBB647:
 1353               	.LBB648:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 1354               		.loc 4 70 0
 1355 05c8 9FBF      		out __SREG__,r25
 1356               		.loc 4 71 0
 1357               	.LBE648:
 1358               	.LBE647:
 1359               	.LBE650:
 1360               	.LBE652:
 1361               	.LBE717:
  22:TakkTile.h    ****     while (!usb_pipe_can_write(&ep_in));
 1362               		.loc 2 22 0
 1363 05ca 8823      		tst r24
 1364 05cc 01F0      		breq .L124
 1365               	.LVL73:
 1366               	.LBB718:
 1367               	.LBB715:
 126:usb/usb_pipe.h **** 		}else{
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 128:usb/usb_pipe.h **** 		}
 129:usb/usb_pipe.h **** 	}
 130:usb/usb_pipe.h **** 	return r;
 131:usb/usb_pipe.h **** }
 132:usb/usb_pipe.h **** 
 133:usb/usb_pipe.h **** static inline uint8_t* usb_pipe_write_ptr(const USB_Pipe* p){
 134:usb/usb_pipe.h **** 	return pipe_write_ptr(p->pipe);
 135:usb/usb_pipe.h **** }
 136:usb/usb_pipe.h **** 
 137:usb/usb_pipe.h **** static inline void usb_pipe_done_write(const USB_Pipe* p){
 138:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 139:usb/usb_pipe.h **** 		pipe_done_write(p->pipe);
 140:usb/usb_pipe.h **** 	}
 141:usb/usb_pipe.h **** }
 142:usb/usb_pipe.h **** 
 143:usb/usb_pipe.h **** static inline bool usb_pipe_can_read(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 144:usb/usb_pipe.h **** static inline bool usb_pipe_can_read(const USB_Pipe* p){
 145:usb/usb_pipe.h **** 	bool r;
 146:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 147:usb/usb_pipe.h **** 		r = pipe_can_read(p->pipe) > 0;
 148:usb/usb_pipe.h **** 	}
 149:usb/usb_pipe.h **** 	return r;
 150:usb/usb_pipe.h **** }
 151:usb/usb_pipe.h **** 
 152:usb/usb_pipe.h **** static inline uint8_t* usb_pipe_read_ptr(const USB_Pipe* p){
 153:usb/usb_pipe.h **** 	return pipe_read_ptr(p->pipe);
 154:usb/usb_pipe.h **** }
 155:usb/usb_pipe.h **** 
 156:usb/usb_pipe.h **** static inline void usb_pipe_done_read(const USB_Pipe* p){
 157:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 158:usb/usb_pipe.h **** 		pipe_done_read(p->pipe);
 159:usb/usb_pipe.h **** 	}
 160:usb/usb_pipe.h **** }
 161:usb/usb_pipe.h **** 
 162:usb/usb_pipe.h **** static inline uint8_t usb_pipe_read_byte(const USB_Pipe* p){
 163:usb/usb_pipe.h **** 	uint8_t r = p->pipe->data->read_ptr[p->data->packet_offset++];
 164:usb/usb_pipe.h **** 	if (p->data->packet_offset == p->pipe->size){
 165:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 166:usb/usb_pipe.h **** 			p->data->packet_offset = 0;
 167:usb/usb_pipe.h **** 			pipe_done_read(p->pipe);
 168:usb/usb_pipe.h **** 			usb_pipe_handle(p);
 169:usb/usb_pipe.h **** 		}
 170:usb/usb_pipe.h **** 	}
 171:usb/usb_pipe.h **** 	return r;
 172:usb/usb_pipe.h **** }
 173:usb/usb_pipe.h **** 
 174:usb/usb_pipe.h **** static inline void usb_pipe_write_byte(const USB_Pipe* p, uint8_t v){
 175:usb/usb_pipe.h **** 	p->pipe->data->write_ptr[p->data->packet_offset++] = v;
 1368               		.loc 3 175 0
 1369 05ce 8091 0000 		lds r24,ep_in_data+2
 1370 05d2 9091 0000 		lds r25,ep_in_data+2+1
 1371 05d6 A091 0000 		lds r26,ep_in_pipe_data+2
 1372 05da B091 0000 		lds r27,ep_in_pipe_data+2+1
 1373 05de A80F      		add r26,r24
 1374 05e0 B91F      		adc r27,r25
 1375 05e2 7C93      		st X,r23
 1376 05e4 0196      		adiw r24,1
 1377 05e6 8093 0000 		sts ep_in_data+2,r24
 1378 05ea 9093 0000 		sts ep_in_data+2+1,r25
 176:usb/usb_pipe.h **** 	if (p->data->packet_offset == p->pipe->size){
 1379               		.loc 3 176 0
 1380 05ee 8034      		cpi r24,64
 1381 05f0 9105      		cpc r25,__zero_reg__
 1382 05f2 01F4      		brne .+2
 1383 05f4 00C0      		rjmp .L221
 1384               	.LVL74:
 1385               	.L125:
 1386               	.LBE715:
 1387               	.LBE718:
 1388               	.LBE721:
 1389               	.LBE723:
 1390               		.loc 1 122 0 discriminator 2
 1391 05f6 80E0      		ldi r24,hi8(sensorData+160)
 1392 05f8 C030      		cpi r28,lo8(sensorData+160)
 1393 05fa D807      		cpc r29,r24
 1394 05fc 01F4      		brne .L136
 1395 05fe C0E0      		ldi r28,lo8(sensorDataPrime)
 1396 0600 D0E0      		ldi r29,hi8(sensorDataPrime)
 1397               	.LVL75:
 1398               	.LBE636:
 1399               	.LBB725:
 1400               	.LBB726:
 1401               	.LBB727:
 1402               	.LBB728:
 1403               	.LBB729:
 1404               	.LBB730:
 1405               	.LBB731:
 1406               	.LBB732:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 1407               		.loc 5 57 0
 1408 0602 16E0      		ldi r17,lo8(6)
 1409               	.LBE732:
 1410               	.LBE731:
 1411               	.LBE730:
 1412               	.LBE729:
 1413               	.LBE728:
 1414               	.LBB743:
 1415               	.LBB744:
 1416               	.LBB745:
 1417               	.LBB746:
 1418               	.LBB747:
 1419               	.LBB748:
 1420               	.LBB749:
 1421               		.loc 5 91 0
 1422 0604 40E0      		ldi r20,lo8(ep_in_pipe_buffer)
 1423 0606 50E0      		ldi r21,hi8(ep_in_pipe_buffer)
 1424               	.LBE749:
 1425               	.LBE748:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 1426               		.loc 3 88 0
 1427 0608 62E0      		ldi r22,lo8(2)
 1428 060a E62E      		mov r14,r22
 1429               	.LBB752:
 1430               	.LBB753:
 1431               	.LBB754:
 1432               	.LBB755:
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1433               		.loc 6 169 0
 1434 060c 20E4      		ldi r18,lo8(64)
 1435 060e 30E0      		ldi r19,0
 1436               	.L151:
 1437               	.LBE755:
 1438               	.LBE754:
 1439               	.LBE753:
 1440               	.LBE752:
 1441               	.LBE747:
 1442               	.LBE746:
 1443               	.LBE745:
 1444               	.LBE744:
 1445               	.LBE743:
 1446               	.LBE727:
 1447               	.LBE726:
 123:TakkI2C.c     **** 		for (uint8_t i = 0; i < 160; i++) send_byte(sensorDataPrime[i]);
 1448               		.loc 1 123 0 discriminator 2
 1449 0610 7991      		ld r23,Y+
 1450               	.LVL76:
 1451               	.L139:
 1452               	.LBB812:
 1453               	.LBB810:
 1454               	.LBB806:
 1455               	.LBB741:
 1456               	.LBB739:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1457               		.loc 3 123 0
 1458 0612 9FB7      		in r25,__SREG__
 1459               	.LVL77:
 1460               	.LBB734:
 1461               	.LBB735:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 1462               		.loc 4 50 0
 1463               	/* #APP */
 1464               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 1465 0614 F894      		cli
 1466               	 ;  0 "" 2
 1467               	.LVL78:
 1468               	/* #NOAPP */
 1469               	.LBE735:
 1470               	.LBE734:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 1471               		.loc 3 124 0
 1472 0616 8091 0000 		lds r24,ep_in_data+1
 1473 061a 8823      		tst r24
 1474 061c 01F4      		brne .+2
 1475 061e 00C0      		rjmp .L222
 1476               	.L169:
 125:usb/usb_pipe.h **** 			r = false;
 1477               		.loc 3 125 0
 1478 0620 80E0      		ldi r24,0
 1479               	.L137:
 1480               	.LBB736:
 1481               	.LBB737:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 1482               		.loc 4 70 0
 1483 0622 9FBF      		out __SREG__,r25
 1484               		.loc 4 71 0
 1485               	.LBE737:
 1486               	.LBE736:
 1487               	.LBE739:
 1488               	.LBE741:
 1489               	.LBE806:
  22:TakkTile.h    ****     while (!usb_pipe_can_write(&ep_in));
 1490               		.loc 2 22 0
 1491 0624 8823      		tst r24
 1492 0626 01F0      		breq .L139
 1493               	.LVL79:
 1494               	.LBB807:
 1495               	.LBB804:
 175:usb/usb_pipe.h **** 	p->pipe->data->write_ptr[p->data->packet_offset++] = v;
 1496               		.loc 3 175 0
 1497 0628 8091 0000 		lds r24,ep_in_data+2
 1498 062c 9091 0000 		lds r25,ep_in_data+2+1
 1499 0630 A091 0000 		lds r26,ep_in_pipe_data+2
 1500 0634 B091 0000 		lds r27,ep_in_pipe_data+2+1
 1501 0638 A80F      		add r26,r24
 1502 063a B91F      		adc r27,r25
 1503 063c 7C93      		st X,r23
 1504 063e 0196      		adiw r24,1
 1505 0640 8093 0000 		sts ep_in_data+2,r24
 1506 0644 9093 0000 		sts ep_in_data+2+1,r25
 1507               		.loc 3 176 0
 1508 0648 8034      		cpi r24,64
 1509 064a 9105      		cpc r25,__zero_reg__
 1510 064c 01F4      		brne .+2
 1511 064e 00C0      		rjmp .L223
 1512               	.LVL80:
 1513               	.L140:
 1514               	.LBE804:
 1515               	.LBE807:
 1516               	.LBE810:
 1517               	.LBE812:
 1518               		.loc 1 123 0 discriminator 2
 1519 0650 80E0      		ldi r24,hi8(sensorDataPrime+160)
 1520 0652 C030      		cpi r28,lo8(sensorDataPrime+160)
 1521 0654 D807      		cpc r29,r24
 1522 0656 01F4      		brne .L151
 1523               	.LVL81:
 1524               	.LBE725:
 1525               	.LBB814:
 1526               	.LBB815:
 1527               	.LBB816:
 1528               	.LBB817:
 110:usb/usb_pipe.h **** 	p->data->flush = 1;
 1529               		.loc 3 110 0
 1530 0658 31E0      		ldi r19,lo8(1)
 1531 065a 3093 0000 		sts ep_in_data+1,r19
 1532               	.LVL82:
 1533               	.LBB818:
 1534               	.LBB819:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1535               		.loc 3 80 0
 1536 065e 6FB7      		in r22,__SREG__
 1537               	.LVL83:
 1538               	.LBB820:
 1539               	.LBB821:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 1540               		.loc 4 50 0
 1541               	/* #APP */
 1542               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 1543 0660 F894      		cli
 1544               	 ;  0 "" 2
 1545               	.LVL84:
 1546               	/* #NOAPP */
 1547               	.LBE821:
 1548               	.LBE820:
 1549               	.LBB822:
 1550               	.LBB823:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 1551               		.loc 6 220 0
 1552 0662 8091 0000 		lds r24,endpoints+24
 1553               	.LBE823:
 1554 0666 8670      		andi r24,lo8(6)
 1555               	.LBE822:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 1556               		.loc 3 82 0
 1557 0668 01F0      		breq .+2
 1558 066a 00C0      		rjmp .L224
 1559               	.LVL85:
 1560               	.L152:
 1561               	.LBB824:
 1562               	.LBB825:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 1563               		.loc 4 70 0
 1564 066c 6FBF      		out __SREG__,r22
 1565               		.loc 4 71 0
 1566               	.LBE825:
 1567               	.LBE824:
 1568               	.LBE819:
 1569               	.LBE818:
 1570               	.LBE817:
 1571               	.LBE816:
  29:TakkTile.h    ****     USB.INTFLAGSBSET = USB_TRNIF_bm;
 1572               		.loc 2 29 0
 1573 066e 82E0      		ldi r24,lo8(2)
 1574 0670 8093 CD04 		sts 1229,r24
 1575               	.LBB860:
 1576               	.LBB861:
 1577               	.LBB862:
 1578               	.LBB863:
 1579               	.LBB864:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 1580               		.loc 5 57 0
 1581 0674 96E0      		ldi r25,lo8(6)
 1582               	.L161:
 1583               	.LVL86:
 1584               	.LBE864:
 1585               	.LBE863:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1586               		.loc 3 123 0
 1587 0676 2FB7      		in r18,__SREG__
 1588               	.LVL87:
 1589               	.LBB866:
 1590               	.LBB867:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 1591               		.loc 4 50 0
 1592               	/* #APP */
 1593               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 1594 0678 F894      		cli
 1595               	 ;  0 "" 2
 1596               	.LVL88:
 1597               	/* #NOAPP */
 1598               	.LBE867:
 1599               	.LBE866:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 1600               		.loc 3 124 0
 1601 067a 8091 0000 		lds r24,ep_in_data+1
 1602 067e 8823      		tst r24
 1603 0680 01F4      		brne .+2
 1604 0682 00C0      		rjmp .L225
 1605               	.L170:
 125:usb/usb_pipe.h **** 			r = false;
 1606               		.loc 3 125 0
 1607 0684 80E0      		ldi r24,0
 1608               	.L162:
 1609               	.LBB868:
 1610               	.LBB869:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 1611               		.loc 4 70 0
 1612 0686 2FBF      		out __SREG__,r18
 1613               		.loc 4 71 0
 1614               	.LBE869:
 1615               	.LBE868:
 1616               	.LBE862:
 1617               	.LBE861:
 1618               	.LBE860:
  30:TakkTile.h    ****     while (!usb_pipe_can_write(&ep_in)){
 1619               		.loc 2 30 0
 1620 0688 8111      		cpse r24,__zero_reg__
 1621 068a 00C0      		rjmp .L121
  31:TakkTile.h    ****         if (timeout_or_sampling_no_longer_enabled){
 1622               		.loc 2 31 0
 1623 068c 8091 0000 		lds r24,timeout_or_sampling_no_longer_enabled
 1624 0690 8823      		tst r24
 1625 0692 01F0      		breq .L161
 1626               	.LVL89:
 1627               	.LBB873:
 1628               	.LBB874:
 1629               	.LBB875:
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1630               		.loc 3 54 0
 1631 0694 2FB7      		in r18,__SREG__
 1632               	.LVL90:
 1633               	.LBB876:
 1634               	.LBB877:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 1635               		.loc 4 50 0
 1636               	/* #APP */
 1637               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 1638 0696 F894      		cli
 1639               	 ;  0 "" 2
 1640               	.LVL91:
 1641               	/* #NOAPP */
 1642               	.LBE877:
 1643               	.LBE876:
 1644               	.LBB878:
 1645               	.LBB879:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 1646               		.loc 5 90 0
 1647 0698 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 1648               		.loc 5 91 0
 1649 069c 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 1650 069e 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 1651 06a0 8093 0000 		sts ep_in_pipe_data+2,r24
 1652 06a4 9093 0000 		sts ep_in_pipe_data+2+1,r25
 1653 06a8 8093 0000 		sts ep_in_pipe_data,r24
 1654 06ac 9093 0000 		sts ep_in_pipe_data+1,r25
 1655               	.LVL92:
 1656               	.LBE879:
 1657               	.LBE878:
 1658               	.LBB880:
 1659               	.LBB881:
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 1660               		.loc 6 158 0
 1661               	/* #APP */
 1662               	 ;  158 "usb/usb.h" 1
 1663 06b0 06E0      		ldi r16, 6
 1664 06b2 0593      		.dc.w 0x9305
 1665               		
 1666               	 ;  0 "" 2
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 1667               		.loc 6 159 0
 1668               	 ;  159 "usb/usb.h" 1
 1669 06b4 08E0      		ldi r16, 8
 1670 06b6 0693      		.dc.w 0x9306
 1671               		
 1672               	 ;  0 "" 2
 1673               	/* #NOAPP */
 1674               	.LBE881:
 1675               	.LBE880:
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
 1676               		.loc 3 57 0
 1677 06b8 1092 0000 		sts ep_in_data+1,__zero_reg__
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
 1678               		.loc 3 58 0
 1679 06bc 1092 0000 		sts ep_in_data+2,__zero_reg__
 1680 06c0 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
 1681               		.loc 3 59 0
 1682 06c4 1092 0000 		sts ep_in_data,__zero_reg__
 1683               	.LVL93:
 1684               	.LBB882:
 1685               	.LBB883:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 1686               		.loc 4 70 0
 1687 06c8 2FBF      		out __SREG__,r18
 1688               		.loc 4 71 0
 1689               	.LVL94:
 1690               	.L121:
 1691               	.LBE883:
 1692               	.LBE882:
 1693               	.LBE875:
 1694               	.LBE874:
 1695               	.LBE873:
 1696               	.LBE815:
 1697               	.LBE814:
 124:TakkI2C.c     **** 		break_and_flush();
 125:TakkI2C.c     **** 	}
 126:TakkI2C.c     **** 	if (SLAVE) {
 1698               		.loc 1 126 0
 1699 06ca 8091 0000 		lds r24,SLAVE
 1700 06ce 8823      		tst r24
 1701 06d0 01F0      		breq .L106
 127:TakkI2C.c     **** 		DMA.CH0.TRFCNT = 160;
 1702               		.loc 1 127 0
 1703 06d2 80EA      		ldi r24,lo8(-96)
 1704 06d4 90E0      		ldi r25,0
 1705 06d6 8093 1401 		sts 276,r24
 1706 06da 9093 1501 		sts 276+1,r25
 128:TakkI2C.c     **** 		DMA.CH0.CTRLA |= DMA_CH_ENABLE_bm;
 1707               		.loc 1 128 0
 1708 06de 8091 1001 		lds r24,272
 1709 06e2 8068      		ori r24,lo8(-128)
 1710 06e4 8093 1001 		sts 272,r24
 129:TakkI2C.c     **** 		DMA.CH0.CTRLA |= DMA_CH_TRFREQ_bm;
 1711               		.loc 1 129 0
 1712 06e8 8091 1001 		lds r24,272
 1713 06ec 8061      		ori r24,lo8(16)
 1714 06ee 8093 1001 		sts 272,r24
 1715               	.L106:
 1716               	/* epilogue start */
 130:TakkI2C.c     **** 	}
 131:TakkI2C.c     **** }
 1717               		.loc 1 131 0
 1718 06f2 DF91      		pop r29
 1719 06f4 CF91      		pop r28
 1720 06f6 1F91      		pop r17
 1721 06f8 0F91      		pop r16
 1722 06fa FF90      		pop r15
 1723 06fc EF90      		pop r14
 1724 06fe 0895      		ret
 1725               	.LVL95:
 1726               	.L115:
 1727               	.LBB887:
 1728               	.LBB635:
 1729               	.LBB633:
 109:TakkI2C.c     **** 			for (uint8_t byteCt = 0; byteCt < 4; byteCt++){
 1730               		.loc 1 109 0
 1731 0700 3F5F      		subi r19,lo8(-(1))
 1732               	.LVL96:
 1733 0702 3430      		cpi r19,lo8(4)
 1734 0704 01F4      		brne .+2
 1735 0706 00C0      		rjmp .L116
 110:TakkI2C.c     **** 				datum = TWIC.MASTER.DATA;
 1736               		.loc 1 110 0
 1737 0708 2091 8704 		lds r18,1159
 1738               	.LVL97:
 111:TakkI2C.c     **** 				sensorData[(cell<<2) + byteCt] = datum;
 1739               		.loc 1 111 0
 1740 070c ED01      		movw r28,r26
 1741 070e C30F      		add r28,r19
 1742 0710 D11D      		adc r29,__zero_reg__
 1743 0712 2883      		st Y,r18
 113:TakkI2C.c     **** 				if (byteCt < 3) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 1744               		.loc 1 113 0
 1745 0714 3330      		cpi r19,lo8(3)
 1746 0716 01F0      		breq .+2
 1747 0718 00C0      		rjmp .L214
 1748 071a 00C0      		rjmp .L116
 1749               	.LVL98:
 1750               	.L220:
 1751               	.LBE633:
 1752               	.LBE635:
 1753               	.LBE887:
 1754               	.LBB888:
 1755               	.LBB724:
 1756               	.LBB722:
 1757               	.LBB719:
 1758               	.LBB653:
 1759               	.LBB651:
 1760               	.LBB649:
 1761               	.LBB644:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 1762               		.loc 5 57 0
 1763 071c 8091 0000 		lds r24,ep_in_pipe_data+4
 1764 0720 612F      		mov r22,r17
 1765 0722 681B      		sub r22,r24
 1766               	.LBE644:
 1767               	.LBE649:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 1768               		.loc 3 127 0
 1769 0724 81E0      		ldi r24,lo8(1)
 1770 0726 1616      		cp __zero_reg__,r22
 1771 0728 04F4      		brge .+2
 1772 072a 00C0      		rjmp .L122
 1773 072c 00C0      		rjmp .L168
 1774               	.LVL99:
 1775               	.L221:
 1776               	.LBE651:
 1777               	.LBE653:
 1778               	.LBE719:
 1779               	.LBB720:
 1780               	.LBB716:
 1781               	.LBB714:
 177:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 1782               		.loc 3 177 0
 1783 072e AFB7      		in r26,__SREG__
 1784               	.LVL100:
 1785               	.LBB706:
 1786               	.LBB707:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 1787               		.loc 4 50 0
 1788               	/* #APP */
 1789               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 1790 0730 F894      		cli
 1791               	 ;  0 "" 2
 1792               	.LVL101:
 1793               	/* #NOAPP */
 1794               	.LBE707:
 1795               	.LBE706:
 178:usb/usb_pipe.h **** 			p->data->packet_offset = 0;
 1796               		.loc 3 178 0
 1797 0732 1092 0000 		sts ep_in_data+2,__zero_reg__
 1798 0736 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 1799               	.LVL102:
 1800               	.LBB708:
 1801               	.LBB709:
  81:usb/pipe.h    **** 	pipe->data->count += 1;
 1802               		.loc 5 81 0
 1803 073a 8091 0000 		lds r24,ep_in_pipe_data+4
 1804 073e 8F5F      		subi r24,lo8(-(1))
 1805 0740 8093 0000 		sts ep_in_pipe_data+4,r24
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
 1806               		.loc 5 82 0
 1807 0744 8091 0000 		lds r24,ep_in_pipe_data+2
 1808 0748 9091 0000 		lds r25,ep_in_pipe_data+2+1
 1809 074c 805C      		subi r24,-64
 1810 074e 9F4F      		sbci r25,-1
 1811 0750 8093 0000 		sts ep_in_pipe_data+2,r24
 1812 0754 9093 0000 		sts ep_in_pipe_data+2+1,r25
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
 1813               		.loc 5 84 0
 1814 0758 8050      		subi r24,lo8(ep_in_pipe_buffer+512)
 1815 075a 9040      		sbci r25,hi8(ep_in_pipe_buffer+512)
 1816 075c 01F4      		brne .L126
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
 1817               		.loc 5 85 0
 1818 075e 4093 0000 		sts ep_in_pipe_data+2,r20
 1819 0762 5093 0000 		sts ep_in_pipe_data+2+1,r21
 1820               	.L126:
 1821               	.LVL103:
 1822               	.LBE709:
 1823               	.LBE708:
 1824               	.LBB710:
 1825               	.LBB704:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1826               		.loc 3 80 0
 1827 0766 FFB6      		in r15,__SREG__
 1828               	.LVL104:
 1829               	.LBB674:
 1830               	.LBB675:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 1831               		.loc 4 50 0
 1832               	/* #APP */
 1833               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 1834 0768 F894      		cli
 1835               	 ;  0 "" 2
 1836               	.LVL105:
 1837               	/* #NOAPP */
 1838               	.LBE675:
 1839               	.LBE674:
 1840               	.LBB676:
 1841               	.LBB677:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 1842               		.loc 6 220 0
 1843 076a 8091 0000 		lds r24,endpoints+24
 1844               	.LBE677:
 1845 076e 8670      		andi r24,lo8(6)
 1846               	.LBE676:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 1847               		.loc 3 82 0
 1848 0770 01F4      		brne .L226
 1849               	.LVL106:
 1850               	.L127:
 1851               	.LBB678:
 1852               	.LBB679:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 1853               		.loc 4 70 0
 1854 0772 FFBE      		out __SREG__,r15
 1855               		.loc 4 71 0
 1856               	.LVL107:
 1857               	.LBE679:
 1858               	.LBE678:
 1859               	.LBE704:
 1860               	.LBE710:
 1861               	.LBB711:
 1862               	.LBB712:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 1863               		.loc 4 70 0
 1864 0774 AFBF      		out __SREG__,r26
 1865               		.loc 4 71 0
 1866 0776 00C0      		rjmp .L125
 1867               	.LVL108:
 1868               	.L226:
 1869               	.LBE712:
 1870               	.LBE711:
 1871               	.LBB713:
 1872               	.LBB705:
 1873               	.LBB680:
 1874               	.LBB681:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 1875               		.loc 5 51 0
 1876 0778 7091 0000 		lds r23,ep_in_pipe_data+4
 1877               	.LVL109:
 1878               	.LBE681:
 1879               	.LBE680:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 1880               		.loc 3 83 0
 1881 077c 1716      		cp __zero_reg__,r23
 1882 077e 04F4      		brge .L128
 1883               	.LBB682:
 1884               	.LBB683:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 1885               		.loc 5 62 0
 1886 0780 8091 0000 		lds r24,ep_in_pipe_data
 1887 0784 9091 0000 		lds r25,ep_in_pipe_data+1
 1888               	.LVL110:
 1889               	.LBE683:
 1890               	.LBE682:
 1891               	.LBB684:
 1892               	.LBB671:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 1893               		.loc 3 68 0
 1894 0788 B091 0000 		lds r27,ep_in_data
 1895               	.LVL111:
 1896               	.LBE671:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1897               		.loc 3 69 0
 1898 078c 61E0      		ldi r22,lo8(1)
 1899 078e 6B27      		eor r22,r27
 1900               	.LBB672:
 1901 0790 6093 0000 		sts ep_in_data,r22
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 1902               		.loc 3 72 0
 1903 0794 B111      		cpse r27,__zero_reg__
 1904 0796 00C0      		rjmp .L129
 1905               	.LVL112:
 1906               	.LBB668:
 1907               	.LBB669:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1908               		.loc 6 168 0
 1909 0798 8093 0000 		sts endpoints+28,r24
 1910 079c 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1911               		.loc 6 169 0
 1912 07a0 2093 0000 		sts endpoints+26,r18
 1913 07a4 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1914               		.loc 6 174 0
 1915               	/* #APP */
 1916               	 ;  174 "usb/usb.h" 1
 1917 07a8 02E2      		ldi r16, 34
 1918 07aa 0693      		.dc.w 0x9306
 1919               		
 1920               	 ;  0 "" 2
 1921               	.LVL113:
 1922               	/* #NOAPP */
 1923               	.L130:
 1924               	.LBE669:
 1925               	.LBE668:
 1926               	.LBE672:
 1927               	.LBE684:
 1928               	.LBB685:
 1929               	.LBB686:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 1930               		.loc 5 72 0
 1931 07ac 7150      		subi r23,lo8(-(-1))
 1932 07ae 7093 0000 		sts ep_in_pipe_data+4,r23
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 1933               		.loc 5 73 0
 1934 07b2 805C      		subi r24,-64
 1935 07b4 9F4F      		sbci r25,-1
 1936               	.LVL114:
 1937 07b6 8093 0000 		sts ep_in_pipe_data,r24
 1938 07ba 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 1939               		.loc 5 75 0
 1940 07be 8050      		subi r24,lo8(ep_in_pipe_buffer+512)
 1941 07c0 9040      		sbci r25,hi8(ep_in_pipe_buffer+512)
 1942 07c2 01F4      		brne .L127
 1943               	.LBE686:
 1944               	.LBE685:
 1945               	.LBB687:
 1946               	.LBB661:
 1947               		.loc 5 91 0
 1948 07c4 4093 0000 		sts ep_in_pipe_data,r20
 1949 07c8 5093 0000 		sts ep_in_pipe_data+1,r21
 1950               	.LVL115:
 1951 07cc 00C0      		rjmp .L127
 1952               	.LVL116:
 1953               	.L129:
 1954               	.LBE661:
 1955               	.LBE687:
 1956               	.LBB688:
 1957               	.LBB673:
 1958               	.LBB670:
 1959               	.LBB667:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1960               		.loc 6 168 0
 1961 07ce 8093 0000 		sts endpoints+20,r24
 1962 07d2 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1963               		.loc 6 169 0
 1964 07d6 2093 0000 		sts endpoints+18,r18
 1965 07da 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 1966               		.loc 6 176 0
 1967               	/* #APP */
 1968               	 ;  176 "usb/usb.h" 1
 1969 07de 04E1      		ldi r16, 20
 1970 07e0 0693      		.dc.w 0x9306
 1971               		
 1972               	 ;  0 "" 2
 1973               	/* #NOAPP */
 1974 07e2 00C0      		rjmp .L130
 1975               	.LVL117:
 1976               	.L128:
 1977               	.LBE667:
 1978               	.LBE670:
 1979               	.LBE673:
 1980               	.LBE688:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 1981               		.loc 3 87 0
 1982 07e4 8091 0000 		lds r24,ep_in_data+1
 1983 07e8 8130      		cpi r24,lo8(1)
 1984 07ea 01F0      		breq .L227
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1985               		.loc 3 91 0
 1986 07ec 8230      		cpi r24,lo8(2)
 1987 07ee 01F0      		breq .+2
 1988 07f0 00C0      		rjmp .L127
 1989               	.LVL118:
 1990               	.LBB689:
 1991               	.LBB690:
 1992               	.LBB691:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 1993               		.loc 6 228 0
 1994 07f2 8091 0000 		lds r24,endpoints+24
 1995 07f6 8670      		andi r24,lo8(6)
 1996               	.LBE691:
 1997               	.LBE690:
 1998               	.LBE689:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1999               		.loc 3 91 0
 2000 07f8 8630      		cpi r24,lo8(6)
 2001 07fa 01F0      		breq .+2
 2002 07fc 00C0      		rjmp .L127
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 2003               		.loc 3 92 0
 2004 07fe 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 2005               		.loc 3 93 0
 2006 0802 1092 0000 		sts ep_in_data+2,__zero_reg__
 2007 0806 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 2008               	.LBB692:
 2009               	.LBB662:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 2010               		.loc 5 90 0
 2011 080a 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 2012               		.loc 5 91 0
 2013 080e 4093 0000 		sts ep_in_pipe_data+2,r20
 2014 0812 5093 0000 		sts ep_in_pipe_data+2+1,r21
 2015 0816 4093 0000 		sts ep_in_pipe_data,r20
 2016 081a 5093 0000 		sts ep_in_pipe_data+1,r21
 2017               	.LVL119:
 2018 081e 00C0      		rjmp .L127
 2019               	.LVL120:
 2020               	.L227:
 2021               	.LBE662:
 2022               	.LBE692:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 2023               		.loc 3 88 0
 2024 0820 E092 0000 		sts ep_in_data+1,r14
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 2025               		.loc 3 90 0
 2026 0824 6091 0000 		lds r22,ep_in_data+2
 2027 0828 7091 0000 		lds r23,ep_in_data+2+1
 2028               	.LBB693:
 2029               	.LBB694:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 2030               		.loc 5 62 0
 2031 082c 0091 0000 		lds r16,ep_in_pipe_data
 2032 0830 B091 0000 		lds r27,ep_in_pipe_data+1
 2033               	.LVL121:
 2034               	.LBE694:
 2035               	.LBE693:
 2036               	.LBB695:
 2037               	.LBB696:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 2038               		.loc 3 68 0
 2039 0834 9091 0000 		lds r25,ep_in_data
 2040               	.LVL122:
 2041               	.LBE696:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 2042               		.loc 3 69 0
 2043 0838 8927      		eor r24,r25
 2044               	.LBB703:
 2045 083a 8093 0000 		sts ep_in_data,r24
 2046               	.LBB697:
 2047               	.LBB698:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2048               		.loc 6 168 0
 2049 083e 802F      		mov r24,r16
 2050               	.LBE698:
 2051               	.LBE697:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 2052               		.loc 3 72 0
 2053 0840 9111      		cpse r25,__zero_reg__
 2054 0842 00C0      		rjmp .L134
 2055               	.LVL123:
 2056               	.LBB700:
 2057               	.LBB699:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2058               		.loc 6 168 0
 2059 0844 9B2F      		mov r25,r27
 2060               	.LVL124:
 2061 0846 8093 0000 		sts endpoints+28,r24
 2062 084a 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2063               		.loc 6 169 0
 2064 084e 6093 0000 		sts endpoints+26,r22
 2065 0852 7093 0000 		sts endpoints+26+1,r23
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 2066               		.loc 6 174 0
 2067               	/* #APP */
 2068               	 ;  174 "usb/usb.h" 1
 2069 0856 02E2      		ldi r16, 34
 2070 0858 0693      		.dc.w 0x9306
 2071               		
 2072               	 ;  0 "" 2
 2073               	.LVL125:
 2074               	/* #NOAPP */
 2075 085a 00C0      		rjmp .L127
 2076               	.LVL126:
 2077               	.L134:
 2078               	.LBE699:
 2079               	.LBE700:
 2080               	.LBB701:
 2081               	.LBB702:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2082               		.loc 6 168 0
 2083 085c 9B2F      		mov r25,r27
 2084               	.LVL127:
 2085 085e 8093 0000 		sts endpoints+20,r24
 2086 0862 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2087               		.loc 6 169 0
 2088 0866 6093 0000 		sts endpoints+18,r22
 2089 086a 7093 0000 		sts endpoints+18+1,r23
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 2090               		.loc 6 176 0
 2091               	/* #APP */
 2092               	 ;  176 "usb/usb.h" 1
 2093 086e 04E1      		ldi r16, 20
 2094 0870 0693      		.dc.w 0x9306
 2095               		
 2096               	 ;  0 "" 2
 2097               	.LVL128:
 2098               	/* #NOAPP */
 2099 0872 00C0      		rjmp .L127
 2100               	.LVL129:
 2101               	.L222:
 2102               	.LBE702:
 2103               	.LBE701:
 2104               	.LBE703:
 2105               	.LBE695:
 2106               	.LBE705:
 2107               	.LBE713:
 2108               	.LBE714:
 2109               	.LBE716:
 2110               	.LBE720:
 2111               	.LBE722:
 2112               	.LBE724:
 2113               	.LBE888:
 2114               	.LBB889:
 2115               	.LBB813:
 2116               	.LBB811:
 2117               	.LBB808:
 2118               	.LBB742:
 2119               	.LBB740:
 2120               	.LBB738:
 2121               	.LBB733:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 2122               		.loc 5 57 0
 2123 0874 8091 0000 		lds r24,ep_in_pipe_data+4
 2124 0878 612F      		mov r22,r17
 2125 087a 681B      		sub r22,r24
 2126               	.LBE733:
 2127               	.LBE738:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 2128               		.loc 3 127 0
 2129 087c 81E0      		ldi r24,lo8(1)
 2130 087e 1616      		cp __zero_reg__,r22
 2131 0880 04F4      		brge .+2
 2132 0882 00C0      		rjmp .L137
 2133 0884 00C0      		rjmp .L169
 2134               	.LVL130:
 2135               	.L223:
 2136               	.LBE740:
 2137               	.LBE742:
 2138               	.LBE808:
 2139               	.LBB809:
 2140               	.LBB805:
 2141               	.LBB803:
 177:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 2142               		.loc 3 177 0
 2143 0886 AFB7      		in r26,__SREG__
 2144               	.LVL131:
 2145               	.LBB795:
 2146               	.LBB796:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 2147               		.loc 4 50 0
 2148               	/* #APP */
 2149               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 2150 0888 F894      		cli
 2151               	 ;  0 "" 2
 2152               	.LVL132:
 2153               	/* #NOAPP */
 2154               	.LBE796:
 2155               	.LBE795:
 2156               		.loc 3 178 0
 2157 088a 1092 0000 		sts ep_in_data+2,__zero_reg__
 2158 088e 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 2159               	.LVL133:
 2160               	.LBB797:
 2161               	.LBB798:
  81:usb/pipe.h    **** 	pipe->data->count += 1;
 2162               		.loc 5 81 0
 2163 0892 8091 0000 		lds r24,ep_in_pipe_data+4
 2164 0896 8F5F      		subi r24,lo8(-(1))
 2165 0898 8093 0000 		sts ep_in_pipe_data+4,r24
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
 2166               		.loc 5 82 0
 2167 089c 8091 0000 		lds r24,ep_in_pipe_data+2
 2168 08a0 9091 0000 		lds r25,ep_in_pipe_data+2+1
 2169 08a4 805C      		subi r24,-64
 2170 08a6 9F4F      		sbci r25,-1
 2171 08a8 8093 0000 		sts ep_in_pipe_data+2,r24
 2172 08ac 9093 0000 		sts ep_in_pipe_data+2+1,r25
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
 2173               		.loc 5 84 0
 2174 08b0 8050      		subi r24,lo8(ep_in_pipe_buffer+512)
 2175 08b2 9040      		sbci r25,hi8(ep_in_pipe_buffer+512)
 2176 08b4 01F4      		brne .L141
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
 2177               		.loc 5 85 0
 2178 08b6 4093 0000 		sts ep_in_pipe_data+2,r20
 2179 08ba 5093 0000 		sts ep_in_pipe_data+2+1,r21
 2180               	.L141:
 2181               	.LVL134:
 2182               	.LBE798:
 2183               	.LBE797:
 2184               	.LBB799:
 2185               	.LBB793:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 2186               		.loc 3 80 0
 2187 08be FFB6      		in r15,__SREG__
 2188               	.LVL135:
 2189               	.LBB763:
 2190               	.LBB764:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 2191               		.loc 4 50 0
 2192               	/* #APP */
 2193               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 2194 08c0 F894      		cli
 2195               	 ;  0 "" 2
 2196               	.LVL136:
 2197               	/* #NOAPP */
 2198               	.LBE764:
 2199               	.LBE763:
 2200               	.LBB765:
 2201               	.LBB766:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 2202               		.loc 6 220 0
 2203 08c2 8091 0000 		lds r24,endpoints+24
 2204               	.LBE766:
 2205 08c6 8670      		andi r24,lo8(6)
 2206               	.LBE765:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 2207               		.loc 3 82 0
 2208 08c8 01F4      		brne .L228
 2209               	.LVL137:
 2210               	.L142:
 2211               	.LBB767:
 2212               	.LBB768:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 2213               		.loc 4 70 0
 2214 08ca FFBE      		out __SREG__,r15
 2215               		.loc 4 71 0
 2216               	.LVL138:
 2217               	.LBE768:
 2218               	.LBE767:
 2219               	.LBE793:
 2220               	.LBE799:
 2221               	.LBB800:
 2222               	.LBB801:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 2223               		.loc 4 70 0
 2224 08cc AFBF      		out __SREG__,r26
 2225               		.loc 4 71 0
 2226 08ce 00C0      		rjmp .L140
 2227               	.LVL139:
 2228               	.L228:
 2229               	.LBE801:
 2230               	.LBE800:
 2231               	.LBB802:
 2232               	.LBB794:
 2233               	.LBB769:
 2234               	.LBB770:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 2235               		.loc 5 51 0
 2236 08d0 7091 0000 		lds r23,ep_in_pipe_data+4
 2237               	.LVL140:
 2238               	.LBE770:
 2239               	.LBE769:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 2240               		.loc 3 83 0
 2241 08d4 1716      		cp __zero_reg__,r23
 2242 08d6 04F4      		brge .L143
 2243               	.LBB771:
 2244               	.LBB772:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 2245               		.loc 5 62 0
 2246 08d8 8091 0000 		lds r24,ep_in_pipe_data
 2247 08dc 9091 0000 		lds r25,ep_in_pipe_data+1
 2248               	.LVL141:
 2249               	.LBE772:
 2250               	.LBE771:
 2251               	.LBB773:
 2252               	.LBB760:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 2253               		.loc 3 68 0
 2254 08e0 B091 0000 		lds r27,ep_in_data
 2255               	.LVL142:
 2256               	.LBE760:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 2257               		.loc 3 69 0
 2258 08e4 61E0      		ldi r22,lo8(1)
 2259 08e6 6B27      		eor r22,r27
 2260               	.LBB761:
 2261 08e8 6093 0000 		sts ep_in_data,r22
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 2262               		.loc 3 72 0
 2263 08ec B111      		cpse r27,__zero_reg__
 2264 08ee 00C0      		rjmp .L144
 2265               	.LVL143:
 2266               	.LBB757:
 2267               	.LBB758:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2268               		.loc 6 168 0
 2269 08f0 8093 0000 		sts endpoints+28,r24
 2270 08f4 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2271               		.loc 6 169 0
 2272 08f8 2093 0000 		sts endpoints+26,r18
 2273 08fc 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 2274               		.loc 6 174 0
 2275               	/* #APP */
 2276               	 ;  174 "usb/usb.h" 1
 2277 0900 02E2      		ldi r16, 34
 2278 0902 0693      		.dc.w 0x9306
 2279               		
 2280               	 ;  0 "" 2
 2281               	.LVL144:
 2282               	/* #NOAPP */
 2283               	.L145:
 2284               	.LBE758:
 2285               	.LBE757:
 2286               	.LBE761:
 2287               	.LBE773:
 2288               	.LBB774:
 2289               	.LBB775:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 2290               		.loc 5 72 0
 2291 0904 7150      		subi r23,lo8(-(-1))
 2292 0906 7093 0000 		sts ep_in_pipe_data+4,r23
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 2293               		.loc 5 73 0
 2294 090a 805C      		subi r24,-64
 2295 090c 9F4F      		sbci r25,-1
 2296               	.LVL145:
 2297 090e 8093 0000 		sts ep_in_pipe_data,r24
 2298 0912 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 2299               		.loc 5 75 0
 2300 0916 8050      		subi r24,lo8(ep_in_pipe_buffer+512)
 2301 0918 9040      		sbci r25,hi8(ep_in_pipe_buffer+512)
 2302 091a 01F4      		brne .L142
 2303               	.LBE775:
 2304               	.LBE774:
 2305               	.LBB776:
 2306               	.LBB750:
 2307               		.loc 5 91 0
 2308 091c 4093 0000 		sts ep_in_pipe_data,r20
 2309 0920 5093 0000 		sts ep_in_pipe_data+1,r21
 2310               	.LVL146:
 2311 0924 00C0      		rjmp .L142
 2312               	.LVL147:
 2313               	.L144:
 2314               	.LBE750:
 2315               	.LBE776:
 2316               	.LBB777:
 2317               	.LBB762:
 2318               	.LBB759:
 2319               	.LBB756:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2320               		.loc 6 168 0
 2321 0926 8093 0000 		sts endpoints+20,r24
 2322 092a 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2323               		.loc 6 169 0
 2324 092e 2093 0000 		sts endpoints+18,r18
 2325 0932 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 2326               		.loc 6 176 0
 2327               	/* #APP */
 2328               	 ;  176 "usb/usb.h" 1
 2329 0936 04E1      		ldi r16, 20
 2330 0938 0693      		.dc.w 0x9306
 2331               		
 2332               	 ;  0 "" 2
 2333               	/* #NOAPP */
 2334 093a 00C0      		rjmp .L145
 2335               	.LVL148:
 2336               	.L143:
 2337               	.LBE756:
 2338               	.LBE759:
 2339               	.LBE762:
 2340               	.LBE777:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 2341               		.loc 3 87 0
 2342 093c 8091 0000 		lds r24,ep_in_data+1
 2343 0940 8130      		cpi r24,lo8(1)
 2344 0942 01F0      		breq .L229
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 2345               		.loc 3 91 0
 2346 0944 8230      		cpi r24,lo8(2)
 2347 0946 01F0      		breq .+2
 2348 0948 00C0      		rjmp .L142
 2349               	.LVL149:
 2350               	.LBB778:
 2351               	.LBB779:
 2352               	.LBB780:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 2353               		.loc 6 228 0
 2354 094a 8091 0000 		lds r24,endpoints+24
 2355 094e 8670      		andi r24,lo8(6)
 2356               	.LBE780:
 2357               	.LBE779:
 2358               	.LBE778:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 2359               		.loc 3 91 0
 2360 0950 8630      		cpi r24,lo8(6)
 2361 0952 01F0      		breq .+2
 2362 0954 00C0      		rjmp .L142
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 2363               		.loc 3 92 0
 2364 0956 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 2365               		.loc 3 93 0
 2366 095a 1092 0000 		sts ep_in_data+2,__zero_reg__
 2367 095e 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 2368               	.LBB781:
 2369               	.LBB751:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 2370               		.loc 5 90 0
 2371 0962 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 2372               		.loc 5 91 0
 2373 0966 4093 0000 		sts ep_in_pipe_data+2,r20
 2374 096a 5093 0000 		sts ep_in_pipe_data+2+1,r21
 2375 096e 4093 0000 		sts ep_in_pipe_data,r20
 2376 0972 5093 0000 		sts ep_in_pipe_data+1,r21
 2377               	.LVL150:
 2378 0976 00C0      		rjmp .L142
 2379               	.LVL151:
 2380               	.L229:
 2381               	.LBE751:
 2382               	.LBE781:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 2383               		.loc 3 88 0
 2384 0978 E092 0000 		sts ep_in_data+1,r14
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 2385               		.loc 3 90 0
 2386 097c 6091 0000 		lds r22,ep_in_data+2
 2387 0980 7091 0000 		lds r23,ep_in_data+2+1
 2388               	.LBB782:
 2389               	.LBB783:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 2390               		.loc 5 62 0
 2391 0984 0091 0000 		lds r16,ep_in_pipe_data
 2392 0988 B091 0000 		lds r27,ep_in_pipe_data+1
 2393               	.LVL152:
 2394               	.LBE783:
 2395               	.LBE782:
 2396               	.LBB784:
 2397               	.LBB785:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 2398               		.loc 3 68 0
 2399 098c 9091 0000 		lds r25,ep_in_data
 2400               	.LVL153:
 2401               	.LBE785:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 2402               		.loc 3 69 0
 2403 0990 8927      		eor r24,r25
 2404               	.LBB792:
 2405 0992 8093 0000 		sts ep_in_data,r24
 2406               	.LBB786:
 2407               	.LBB787:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2408               		.loc 6 168 0
 2409 0996 802F      		mov r24,r16
 2410               	.LBE787:
 2411               	.LBE786:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 2412               		.loc 3 72 0
 2413 0998 9111      		cpse r25,__zero_reg__
 2414 099a 00C0      		rjmp .L149
 2415               	.LVL154:
 2416               	.LBB789:
 2417               	.LBB788:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2418               		.loc 6 168 0
 2419 099c 9B2F      		mov r25,r27
 2420               	.LVL155:
 2421 099e 8093 0000 		sts endpoints+28,r24
 2422 09a2 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2423               		.loc 6 169 0
 2424 09a6 6093 0000 		sts endpoints+26,r22
 2425 09aa 7093 0000 		sts endpoints+26+1,r23
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 2426               		.loc 6 174 0
 2427               	/* #APP */
 2428               	 ;  174 "usb/usb.h" 1
 2429 09ae 02E2      		ldi r16, 34
 2430 09b0 0693      		.dc.w 0x9306
 2431               		
 2432               	 ;  0 "" 2
 2433               	.LVL156:
 2434               	/* #NOAPP */
 2435 09b2 00C0      		rjmp .L142
 2436               	.LVL157:
 2437               	.L149:
 2438               	.LBE788:
 2439               	.LBE789:
 2440               	.LBB790:
 2441               	.LBB791:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2442               		.loc 6 168 0
 2443 09b4 9B2F      		mov r25,r27
 2444               	.LVL158:
 2445 09b6 8093 0000 		sts endpoints+20,r24
 2446 09ba 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2447               		.loc 6 169 0
 2448 09be 6093 0000 		sts endpoints+18,r22
 2449 09c2 7093 0000 		sts endpoints+18+1,r23
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 2450               		.loc 6 176 0
 2451               	/* #APP */
 2452               	 ;  176 "usb/usb.h" 1
 2453 09c6 04E1      		ldi r16, 20
 2454 09c8 0693      		.dc.w 0x9306
 2455               		
 2456               	 ;  0 "" 2
 2457               	.LVL159:
 2458               	/* #NOAPP */
 2459 09ca 00C0      		rjmp .L142
 2460               	.LVL160:
 2461               	.L225:
 2462               	.LBE791:
 2463               	.LBE790:
 2464               	.LBE792:
 2465               	.LBE784:
 2466               	.LBE794:
 2467               	.LBE802:
 2468               	.LBE803:
 2469               	.LBE805:
 2470               	.LBE809:
 2471               	.LBE811:
 2472               	.LBE813:
 2473               	.LBE889:
 2474               	.LBB890:
 2475               	.LBB886:
 2476               	.LBB884:
 2477               	.LBB872:
 2478               	.LBB871:
 2479               	.LBB870:
 2480               	.LBB865:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 2481               		.loc 5 57 0
 2482 09cc 8091 0000 		lds r24,ep_in_pipe_data+4
 2483 09d0 392F      		mov r19,r25
 2484 09d2 381B      		sub r19,r24
 2485               	.LBE865:
 2486               	.LBE870:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 2487               		.loc 3 127 0
 2488 09d4 81E0      		ldi r24,lo8(1)
 2489 09d6 1316      		cp __zero_reg__,r19
 2490 09d8 04F4      		brge .+2
 2491 09da 00C0      		rjmp .L162
 2492 09dc 00C0      		rjmp .L170
 2493               	.LVL161:
 2494               	.L224:
 2495               	.LBE871:
 2496               	.LBE872:
 2497               	.LBE884:
 2498               	.LBB885:
 2499               	.LBB859:
 2500               	.LBB858:
 2501               	.LBB857:
 2502               	.LBB826:
 2503               	.LBB827:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 2504               		.loc 5 51 0
 2505 09de 4091 0000 		lds r20,ep_in_pipe_data+4
 2506               	.LBE827:
 2507               	.LBE826:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 2508               		.loc 3 83 0
 2509 09e2 1416      		cp __zero_reg__,r20
 2510 09e4 04F0      		brlt .+2
 2511 09e6 00C0      		rjmp .L153
 2512               	.LBB828:
 2513               	.LBB829:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 2514               		.loc 5 62 0
 2515 09e8 8091 0000 		lds r24,ep_in_pipe_data
 2516 09ec 9091 0000 		lds r25,ep_in_pipe_data+1
 2517               	.LVL162:
 2518               	.LBE829:
 2519               	.LBE828:
 2520               	.LBB830:
 2521               	.LBB831:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 2522               		.loc 3 68 0
 2523 09f0 2091 0000 		lds r18,ep_in_data
 2524               	.LVL163:
 2525               	.LBE831:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 2526               		.loc 3 69 0
 2527 09f4 3227      		eor r19,r18
 2528               	.LBB836:
 2529 09f6 3093 0000 		sts ep_in_data,r19
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 2530               		.loc 3 72 0
 2531 09fa 2111      		cpse r18,__zero_reg__
 2532 09fc 00C0      		rjmp .L154
 2533               	.LVL164:
 2534               	.LBB832:
 2535               	.LBB833:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2536               		.loc 6 168 0
 2537 09fe 8093 0000 		sts endpoints+28,r24
 2538 0a02 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2539               		.loc 6 169 0
 2540 0a06 20E4      		ldi r18,lo8(64)
 2541 0a08 30E0      		ldi r19,0
 2542               	.LVL165:
 2543 0a0a 2093 0000 		sts endpoints+26,r18
 2544 0a0e 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 2545               		.loc 6 174 0
 2546               	/* #APP */
 2547               	 ;  174 "usb/usb.h" 1
 2548 0a12 02E2      		ldi r16, 34
 2549 0a14 0693      		.dc.w 0x9306
 2550               		
 2551               	 ;  0 "" 2
 2552               	.LVL166:
 2553               	/* #NOAPP */
 2554               	.L155:
 2555               	.LBE833:
 2556               	.LBE832:
 2557               	.LBE836:
 2558               	.LBE830:
 2559               	.LBB838:
 2560               	.LBB839:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 2561               		.loc 5 72 0
 2562 0a16 4150      		subi r20,lo8(-(-1))
 2563 0a18 4093 0000 		sts ep_in_pipe_data+4,r20
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 2564               		.loc 5 73 0
 2565 0a1c 805C      		subi r24,-64
 2566 0a1e 9F4F      		sbci r25,-1
 2567               	.LVL167:
 2568 0a20 8093 0000 		sts ep_in_pipe_data,r24
 2569 0a24 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 2570               		.loc 5 75 0
 2571 0a28 8050      		subi r24,lo8(ep_in_pipe_buffer+512)
 2572 0a2a 9040      		sbci r25,hi8(ep_in_pipe_buffer+512)
 2573 0a2c 01F0      		breq .+2
 2574 0a2e 00C0      		rjmp .L152
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 2575               		.loc 5 76 0
 2576 0a30 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 2577 0a32 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 2578 0a34 8093 0000 		sts ep_in_pipe_data,r24
 2579 0a38 9093 0000 		sts ep_in_pipe_data+1,r25
 2580 0a3c 00C0      		rjmp .L152
 2581               	.LVL168:
 2582               	.L154:
 2583               	.LBE839:
 2584               	.LBE838:
 2585               	.LBB840:
 2586               	.LBB837:
 2587               	.LBB834:
 2588               	.LBB835:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2589               		.loc 6 168 0
 2590 0a3e 8093 0000 		sts endpoints+20,r24
 2591 0a42 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2592               		.loc 6 169 0
 2593 0a46 20E4      		ldi r18,lo8(64)
 2594 0a48 30E0      		ldi r19,0
 2595               	.LVL169:
 2596 0a4a 2093 0000 		sts endpoints+18,r18
 2597 0a4e 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 2598               		.loc 6 176 0
 2599               	/* #APP */
 2600               	 ;  176 "usb/usb.h" 1
 2601 0a52 04E1      		ldi r16, 20
 2602 0a54 0693      		.dc.w 0x9306
 2603               		
 2604               	 ;  0 "" 2
 2605               	/* #NOAPP */
 2606 0a56 00C0      		rjmp .L155
 2607               	.LVL170:
 2608               	.L153:
 2609               	.LBE835:
 2610               	.LBE834:
 2611               	.LBE837:
 2612               	.LBE840:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 2613               		.loc 3 87 0
 2614 0a58 8091 0000 		lds r24,ep_in_data+1
 2615 0a5c 8130      		cpi r24,lo8(1)
 2616 0a5e 01F0      		breq .L230
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 2617               		.loc 3 91 0
 2618 0a60 8230      		cpi r24,lo8(2)
 2619 0a62 01F0      		breq .+2
 2620 0a64 00C0      		rjmp .L152
 2621               	.LVL171:
 2622               	.LBB841:
 2623               	.LBB842:
 2624               	.LBB843:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 2625               		.loc 6 228 0
 2626 0a66 8091 0000 		lds r24,endpoints+24
 2627 0a6a 8670      		andi r24,lo8(6)
 2628               	.LBE843:
 2629               	.LBE842:
 2630               	.LBE841:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 2631               		.loc 3 91 0
 2632 0a6c 8630      		cpi r24,lo8(6)
 2633 0a6e 01F0      		breq .+2
 2634 0a70 00C0      		rjmp .L152
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 2635               		.loc 3 92 0
 2636 0a72 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 2637               		.loc 3 93 0
 2638 0a76 1092 0000 		sts ep_in_data+2,__zero_reg__
 2639 0a7a 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 2640               	.LBB844:
 2641               	.LBB845:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 2642               		.loc 5 90 0
 2643 0a7e 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 2644               		.loc 5 91 0
 2645 0a82 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 2646 0a84 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 2647 0a86 8093 0000 		sts ep_in_pipe_data+2,r24
 2648 0a8a 9093 0000 		sts ep_in_pipe_data+2+1,r25
 2649 0a8e 8093 0000 		sts ep_in_pipe_data,r24
 2650 0a92 9093 0000 		sts ep_in_pipe_data+1,r25
 2651               	.LVL172:
 2652 0a96 00C0      		rjmp .L152
 2653               	.LVL173:
 2654               	.L230:
 2655               	.LBE845:
 2656               	.LBE844:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 2657               		.loc 3 88 0
 2658 0a98 92E0      		ldi r25,lo8(2)
 2659 0a9a 9093 0000 		sts ep_in_data+1,r25
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 2660               		.loc 3 90 0
 2661 0a9e 2091 0000 		lds r18,ep_in_data+2
 2662 0aa2 3091 0000 		lds r19,ep_in_data+2+1
 2663               	.LBB846:
 2664               	.LBB847:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 2665               		.loc 5 62 0
 2666 0aa6 5091 0000 		lds r21,ep_in_pipe_data
 2667 0aaa 4091 0000 		lds r20,ep_in_pipe_data+1
 2668               	.LVL174:
 2669               	.LBE847:
 2670               	.LBE846:
 2671               	.LBB848:
 2672               	.LBB849:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 2673               		.loc 3 68 0
 2674 0aae 9091 0000 		lds r25,ep_in_data
 2675               	.LVL175:
 2676               	.LBE849:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 2677               		.loc 3 69 0
 2678 0ab2 8927      		eor r24,r25
 2679               	.LBB856:
 2680 0ab4 8093 0000 		sts ep_in_data,r24
 2681               	.LBB850:
 2682               	.LBB851:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2683               		.loc 6 168 0
 2684 0ab8 852F      		mov r24,r21
 2685               	.LBE851:
 2686               	.LBE850:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 2687               		.loc 3 72 0
 2688 0aba 9111      		cpse r25,__zero_reg__
 2689 0abc 00C0      		rjmp .L159
 2690               	.LVL176:
 2691               	.LBB853:
 2692               	.LBB852:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2693               		.loc 6 168 0
 2694 0abe 942F      		mov r25,r20
 2695               	.LVL177:
 2696 0ac0 8093 0000 		sts endpoints+28,r24
 2697 0ac4 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2698               		.loc 6 169 0
 2699 0ac8 2093 0000 		sts endpoints+26,r18
 2700 0acc 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 2701               		.loc 6 174 0
 2702               	/* #APP */
 2703               	 ;  174 "usb/usb.h" 1
 2704 0ad0 02E2      		ldi r16, 34
 2705 0ad2 0693      		.dc.w 0x9306
 2706               		
 2707               	 ;  0 "" 2
 2708               	/* #NOAPP */
 2709 0ad4 00C0      		rjmp .L152
 2710               	.LVL178:
 2711               	.L159:
 2712               	.LBE852:
 2713               	.LBE853:
 2714               	.LBB854:
 2715               	.LBB855:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2716               		.loc 6 168 0
 2717 0ad6 942F      		mov r25,r20
 2718               	.LVL179:
 2719 0ad8 8093 0000 		sts endpoints+20,r24
 2720 0adc 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2721               		.loc 6 169 0
 2722 0ae0 2093 0000 		sts endpoints+18,r18
 2723 0ae4 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 2724               		.loc 6 176 0
 2725               	/* #APP */
 2726               	 ;  176 "usb/usb.h" 1
 2727 0ae8 04E1      		ldi r16, 20
 2728 0aea 0693      		.dc.w 0x9306
 2729               		
 2730               	 ;  0 "" 2
 2731               	/* #NOAPP */
 2732 0aec 00C0      		rjmp .L152
 2733               	.LBE855:
 2734               	.LBE854:
 2735               	.LBE856:
 2736               	.LBE848:
 2737               	.LBE857:
 2738               	.LBE858:
 2739               	.LBE859:
 2740               	.LBE885:
 2741               	.LBE886:
 2742               	.LBE890:
 2743               		.cfi_endproc
 2744               	.LFE65:
 2746               	.global	getAliveFlat
 2748               	getAliveFlat:
 2749               	.LFB66:
 132:TakkI2C.c     **** 
 133:TakkI2C.c     **** 
 134:TakkI2C.c     **** void getAliveFlat(void){
 2750               		.loc 1 134 0
 2751               		.cfi_startproc
 2752               	/* prologue: function */
 2753               	/* frame size = 0 */
 2754               	/* stack size = 0 */
 2755               	.L__stack_usage = 0
 2756               	.LVL180:
 2757               	.LBB909:
 2758               	.LBB910:
 2759               		.file 7 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/
   1:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 2760               		.loc 7 164 0
 2761 0aee 8FE3      		ldi r24,lo8(7999)
 2762 0af0 9FE1      		ldi r25,hi8(7999)
 2763 0af2 0197      		1: sbiw r24,1
 2764 0af4 01F4      		brne 1b
 2765 0af6 00C0      		rjmp .
 2766 0af8 0000      		nop
 2767               	.LVL181:
 2768 0afa 20E0      		ldi r18,lo8(aliveCells)
 2769 0afc 30E0      		ldi r19,hi8(aliveCells)
 2770               	.LBE910:
 2771               	.LBE909:
 2772               		.loc 1 134 0
 2773 0afe F901      		movw r30,r18
 2774               	.LBB912:
 2775               	.LBB913:
 2776               	.LBB914:
 2777               	.LBB915:
   9:TakkI2C.c     **** inline uint8_t calcTinyAddrFlat(uint8_t cell) { return (((cell/5)&0x0F) << 4 | ((cell%5)&0x07) << 1
 2778               		.loc 1 9 0
 2779 0b00 5DEC      		ldi r21,lo8(-51)
 2780               	.LBE915:
 2781               	.LBE914:
 2782               	.LBB917:
 2783               	.LBB918:
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 2784               		.loc 1 19 0
 2785 0b02 70EC      		ldi r23,lo8(-64)
 2786               	.LBE918:
 2787               	.LBE917:
 135:TakkI2C.c     **** 	_delay_ms(1);
 136:TakkI2C.c     **** 	for (uint8_t cell = 0; cell < 40; cell++){
 137:TakkI2C.c     **** 		uint8_t tinyAddr = calcTinyAddrFlat(cell);
 138:TakkI2C.c     **** 		if (botherAddress(tinyAddr, 1) == 1) {
 139:TakkI2C.c     **** 			_delay_us(5);
 140:TakkI2C.c     **** 			if (botherAddress(0xC0, 1) == 1) aliveCells[cell] = 0xFF;
 141:TakkI2C.c     **** 			_delay_us(5);
 142:TakkI2C.c     **** 			botherAddress(tinyAddr^1, 1);
 2788               		.loc 1 142 0
 2789 0b04 61E0      		ldi r22,lo8(1)
 140:TakkI2C.c     **** 			if (botherAddress(0xC0, 1) == 1) aliveCells[cell] = 0xFF;
 2790               		.loc 1 140 0
 2791 0b06 AFEF      		ldi r26,lo8(-1)
 2792               	.LVL182:
 2793               	.L237:
 2794               	.LBE913:
 2795               	.LBE912:
 2796               	.LBB934:
 2797               	.LBB911:
 134:TakkI2C.c     **** void getAliveFlat(void){
 2798               		.loc 1 134 0
 2799 0b08 4E2F      		mov r20,r30
 2800 0b0a 421B      		sub r20,r18
 2801               	.LVL183:
 2802               	.LBE911:
 2803               	.LBE934:
 2804               	.LBB935:
 2805               	.LBB932:
 2806               	.LBB920:
 2807               	.LBB916:
   9:TakkI2C.c     **** inline uint8_t calcTinyAddrFlat(uint8_t cell) { return (((cell/5)&0x0F) << 4 | ((cell%5)&0x07) << 1
 2808               		.loc 1 9 0
 2809 0b0c 459F      		mul r20,r21
 2810 0b0e 812D      		mov r24,r1
 2811 0b10 1124      		clr __zero_reg__
 2812 0b12 8695      		lsr r24
 2813 0b14 8695      		lsr r24
 2814 0b16 982F      		mov r25,r24
 2815 0b18 990F      		lsl r25
 2816 0b1a 990F      		lsl r25
 2817 0b1c 980F      		add r25,r24
 2818 0b1e 491B      		sub r20,r25
 2819               	.LVL184:
 2820 0b20 440F      		lsl r20
 2821 0b22 B0E1      		ldi r27,lo8(16)
 2822 0b24 8B9F      		mul r24,r27
 2823 0b26 C001      		movw r24,r0
 2824 0b28 1124      		clr __zero_reg__
 2825 0b2a 482B      		or r20,r24
 2826               	.LVL185:
 2827               	.LBE916:
 2828               	.LBE920:
 2829               	.LBB921:
 2830               	.LBB922:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 2831               		.loc 1 17 0
 2832 0b2c 8091 8204 		lds r24,1154
 2833 0b30 8260      		ori r24,lo8(2)
 2834 0b32 8093 8204 		sts 1154,r24
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 2835               		.loc 1 19 0
 2836 0b36 4093 8604 		sts 1158,r20
 2837               	.L232:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 2838               		.loc 1 23 0
 2839 0b3a 8091 8404 		lds r24,1156
 2840 0b3e 86FF      		sbrs r24,6
 2841 0b40 00C0      		rjmp .L232
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 2842               		.loc 1 25 0
 2843 0b42 8091 8304 		lds r24,1155
 2844 0b46 8360      		ori r24,lo8(3)
 2845 0b48 8093 8304 		sts 1155,r24
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 2846               		.loc 1 27 0
 2847 0b4c 8091 8404 		lds r24,1156
 2848               	.LBE922:
 2849               	.LBE921:
 138:TakkI2C.c     **** 		if (botherAddress(tinyAddr, 1) == 1) {
 2850               		.loc 1 138 0
 2851 0b50 84FF      		sbrs r24,4
 2852 0b52 00C0      		rjmp .L248
 2853               	.LVL186:
 2854               	.L233:
 2855 0b54 3196      		adiw r30,1
 2856               	.LVL187:
 2857               	.LBE932:
 136:TakkI2C.c     **** 	for (uint8_t cell = 0; cell < 40; cell++){
 2858               		.loc 1 136 0
 2859 0b56 80E0      		ldi r24,hi8(aliveCells+40)
 2860 0b58 E030      		cpi r30,lo8(aliveCells+40)
 2861 0b5a F807      		cpc r31,r24
 2862 0b5c 01F4      		brne .L237
 2863               	/* epilogue start */
 2864               	.LBE935:
 143:TakkI2C.c     **** 			_delay_us(5);
 144:TakkI2C.c     **** 		}
 145:TakkI2C.c     **** 	}
 146:TakkI2C.c     **** }
 2865               		.loc 1 146 0
 2866 0b5e 0895      		ret
 2867               	.LVL188:
 2868               	.L248:
 2869               	.LBB936:
 2870               	.LBB933:
 2871               	.LBB923:
 2872               	.LBB924:
 165:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 166:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** }
 187:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 188:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 191:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 193:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 196:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 198:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 202:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   
 207:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 211:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****  
 214:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 222:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** void
 224:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** {
 226:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 235:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 238:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 241:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 246:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 2873               		.loc 7 246 0
 2874 0b60 85E3      		ldi r24,lo8(53)
 2875 0b62 8A95      		1: dec r24
 2876 0b64 01F4      		brne 1b
 2877 0b66 0000      		nop
 2878               	.LVL189:
 2879               	.LBE924:
 2880               	.LBE923:
 2881               	.LBB925:
 2882               	.LBB919:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 2883               		.loc 1 17 0
 2884 0b68 8091 8204 		lds r24,1154
 2885 0b6c 8260      		ori r24,lo8(2)
 2886 0b6e 8093 8204 		sts 1154,r24
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 2887               		.loc 1 19 0
 2888 0b72 7093 8604 		sts 1158,r23
 2889               	.L234:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 2890               		.loc 1 23 0
 2891 0b76 8091 8404 		lds r24,1156
 2892 0b7a 86FF      		sbrs r24,6
 2893 0b7c 00C0      		rjmp .L234
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 2894               		.loc 1 25 0
 2895 0b7e 8091 8304 		lds r24,1155
 2896 0b82 8360      		ori r24,lo8(3)
 2897 0b84 8093 8304 		sts 1155,r24
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 2898               		.loc 1 27 0
 2899 0b88 8091 8404 		lds r24,1156
 2900               	.LBE919:
 2901               	.LBE925:
 140:TakkI2C.c     **** 			if (botherAddress(0xC0, 1) == 1) aliveCells[cell] = 0xFF;
 2902               		.loc 1 140 0
 2903 0b8c 84FF      		sbrs r24,4
 2904 0b8e 00C0      		rjmp .L249
 2905               	.L235:
 2906               	.LVL190:
 2907               	.LBB926:
 2908               	.LBB927:
 2909               		.loc 7 246 0
 2910 0b90 95E3      		ldi r25,lo8(53)
 2911 0b92 9A95      		1: dec r25
 2912 0b94 01F4      		brne 1b
 2913 0b96 0000      		nop
 2914               	.LBE927:
 2915               	.LBE926:
 142:TakkI2C.c     **** 			botherAddress(tinyAddr^1, 1);
 2916               		.loc 1 142 0
 2917 0b98 4627      		eor r20,r22
 2918               	.LVL191:
 2919               	.LBB928:
 2920               	.LBB929:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 2921               		.loc 1 17 0
 2922 0b9a 8091 8204 		lds r24,1154
 2923 0b9e 8260      		ori r24,lo8(2)
 2924 0ba0 8093 8204 		sts 1154,r24
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 2925               		.loc 1 19 0
 2926 0ba4 4093 8604 		sts 1158,r20
 2927               	.L236:
  21:TakkI2C.c     **** 	if (address & 1) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 2928               		.loc 1 21 0
 2929 0ba8 8091 8404 		lds r24,1156
 2930 0bac 87FF      		sbrs r24,7
 2931 0bae 00C0      		rjmp .L236
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 2932               		.loc 1 25 0
 2933 0bb0 8091 8304 		lds r24,1155
 2934 0bb4 8360      		ori r24,lo8(3)
 2935 0bb6 8093 8304 		sts 1155,r24
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 2936               		.loc 1 27 0
 2937 0bba 8091 8404 		lds r24,1156
 2938               	.LVL192:
 2939               	.LBE929:
 2940               	.LBE928:
 2941               	.LBB930:
 2942               	.LBB931:
 2943               		.loc 7 246 0
 2944 0bbe B5E3      		ldi r27,lo8(53)
 2945 0bc0 BA95      		1: dec r27
 2946 0bc2 01F4      		brne 1b
 2947 0bc4 0000      		nop
 2948 0bc6 00C0      		rjmp .L233
 2949               	.LVL193:
 2950               	.L249:
 2951               	.LBE931:
 2952               	.LBE930:
 140:TakkI2C.c     **** 			if (botherAddress(0xC0, 1) == 1) aliveCells[cell] = 0xFF;
 2953               		.loc 1 140 0 discriminator 1
 2954 0bc8 A083      		st Z,r26
 2955 0bca 00C0      		rjmp .L235
 2956               	.LBE933:
 2957               	.LBE936:
 2958               		.cfi_endproc
 2959               	.LFE66:
 2961               	.global	__vector_16
 2963               	__vector_16:
 2964               	.LFB67:
 2965               		.file 8 "main.c"
   1:main.c        **** // (C) 2012 Biorobotics Lab and Nonolith Labs
   2:main.c        **** // (C) 2011, 2012 Ian Daniher (Nonolith Labs) <ian@nonolithlabs.com>
   3:main.c        **** // (C) 2012 Kevin Mehall (Nonolith Labs) <kevin@nonolithlabs.com>
   4:main.c        **** // Licensed under the terms of the GNU GPLv3+
   5:main.c        **** 
   6:main.c        **** #include "TakkTile.h"
   7:main.c        **** #include "TakkI2C.c"
   8:main.c        **** 
   9:main.c        **** // run I2C at 1MHz
  10:main.c        **** #define F_TWI	1000000
  11:main.c        **** #define TWI_BAUD ((F_CPU / (2 * F_TWI)) - 5) 
  12:main.c        **** 
  13:main.c        **** ISR(TCC0_CCA_vect){
 2966               		.loc 8 13 0
 2967               		.cfi_startproc
 2968 0bcc 1F92      		push r1
 2969               	.LCFI35:
 2970               		.cfi_def_cfa_offset 3
 2971               		.cfi_offset 1, -2
 2972 0bce 0F92      		push r0
 2973               	.LCFI36:
 2974               		.cfi_def_cfa_offset 4
 2975               		.cfi_offset 0, -3
 2976 0bd0 0FB6      		in r0,__SREG__
 2977 0bd2 0F92      		push r0
 2978 0bd4 1124      		clr __zero_reg__
 2979 0bd6 2F93      		push r18
 2980               	.LCFI37:
 2981               		.cfi_def_cfa_offset 5
 2982               		.cfi_offset 18, -4
 2983 0bd8 3F93      		push r19
 2984               	.LCFI38:
 2985               		.cfi_def_cfa_offset 6
 2986               		.cfi_offset 19, -5
 2987 0bda 4F93      		push r20
 2988               	.LCFI39:
 2989               		.cfi_def_cfa_offset 7
 2990               		.cfi_offset 20, -6
 2991 0bdc 5F93      		push r21
 2992               	.LCFI40:
 2993               		.cfi_def_cfa_offset 8
 2994               		.cfi_offset 21, -7
 2995 0bde 6F93      		push r22
 2996               	.LCFI41:
 2997               		.cfi_def_cfa_offset 9
 2998               		.cfi_offset 22, -8
 2999 0be0 7F93      		push r23
 3000               	.LCFI42:
 3001               		.cfi_def_cfa_offset 10
 3002               		.cfi_offset 23, -9
 3003 0be2 8F93      		push r24
 3004               	.LCFI43:
 3005               		.cfi_def_cfa_offset 11
 3006               		.cfi_offset 24, -10
 3007 0be4 9F93      		push r25
 3008               	.LCFI44:
 3009               		.cfi_def_cfa_offset 12
 3010               		.cfi_offset 25, -11
 3011 0be6 AF93      		push r26
 3012               	.LCFI45:
 3013               		.cfi_def_cfa_offset 13
 3014               		.cfi_offset 26, -12
 3015 0be8 BF93      		push r27
 3016               	.LCFI46:
 3017               		.cfi_def_cfa_offset 14
 3018               		.cfi_offset 27, -13
 3019 0bea CF93      		push r28
 3020               	.LCFI47:
 3021               		.cfi_def_cfa_offset 15
 3022               		.cfi_offset 28, -14
 3023 0bec DF93      		push r29
 3024               	.LCFI48:
 3025               		.cfi_def_cfa_offset 16
 3026               		.cfi_offset 29, -15
 3027 0bee EF93      		push r30
 3028               	.LCFI49:
 3029               		.cfi_def_cfa_offset 17
 3030               		.cfi_offset 30, -16
 3031 0bf0 FF93      		push r31
 3032               	.LCFI50:
 3033               		.cfi_def_cfa_offset 18
 3034               		.cfi_offset 31, -17
 3035               	/* prologue: Signal */
 3036               	/* frame size = 0 */
 3037               	/* stack size = 17 */
 3038               	.L__stack_usage = 17
  14:main.c        **** 	// Timer interrupt that trips 1ms after TCC0.CNT is set to 0.
  15:main.c        **** 	// Clock out all data from all alive sensors, and start next conversion
  16:main.c        **** 
  17:main.c        **** 	getSensorData();
 3039               		.loc 8 17 0
 3040 0bf2 0E94 0000 		call getSensorData
 3041               	.LVL194:
 3042               	.LBB945:
 3043               	.LBB946:
 3044               	.LBB947:
 3045               	.LBB948:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 3046               		.loc 1 17 0
 3047 0bf6 8091 8204 		lds r24,1154
 3048 0bfa 8260      		ori r24,lo8(2)
 3049 0bfc 8093 8204 		sts 1154,r24
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 3050               		.loc 1 19 0
 3051 0c00 8CE0      		ldi r24,lo8(12)
 3052 0c02 8093 8604 		sts 1158,r24
 3053               	.L251:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3054               		.loc 1 23 0
 3055 0c06 8091 8404 		lds r24,1156
 3056 0c0a 86FF      		sbrs r24,6
 3057 0c0c 00C0      		rjmp .L251
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 3058               		.loc 1 25 0
 3059 0c0e 8091 8304 		lds r24,1155
 3060 0c12 8360      		ori r24,lo8(3)
 3061 0c14 8093 8304 		sts 1155,r24
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 3062               		.loc 1 27 0
 3063 0c18 8091 8404 		lds r24,1156
 3064 0c1c 8295      		swap r24
 3065 0c1e 8170      		andi r24,1
 3066 0c20 C82F      		mov r28,r24
 3067 0c22 80E0      		ldi r24,0
 3068 0c24 D82F      		mov r29,r24
 3069               	.LBE948:
 3070 0c26 81E0      		ldi r24,1
 3071 0c28 C827      		eor r28,r24
 3072               	.LVL195:
 3073               	.LBE947:
 3074               	.LBB949:
 3075               	.LBB950:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 3076               		.loc 1 17 0
 3077 0c2a 8091 8204 		lds r24,1154
 3078 0c2e 8260      		ori r24,lo8(2)
 3079 0c30 8093 8204 		sts 1154,r24
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 3080               		.loc 1 19 0
 3081 0c34 80EC      		ldi r24,lo8(-64)
 3082 0c36 8093 8604 		sts 1158,r24
 3083               	.L252:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3084               		.loc 1 23 0
 3085 0c3a 8091 8404 		lds r24,1156
 3086 0c3e 86FF      		sbrs r24,6
 3087 0c40 00C0      		rjmp .L252
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 3088               		.loc 1 27 0
 3089 0c42 8091 8404 		lds r24,1156
 3090               	.LBE950:
 3091               	.LBE949:
  39:TakkI2C.c     **** 	TWIC.MASTER.DATA = 0x12;
 3092               		.loc 1 39 0
 3093 0c46 82E1      		ldi r24,lo8(18)
 3094 0c48 8093 8704 		sts 1159,r24
 3095               	.L253:
  40:TakkI2C.c     **** 	while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3096               		.loc 1 40 0
 3097 0c4c 8091 8404 		lds r24,1156
 3098 0c50 86FF      		sbrs r24,6
 3099 0c52 00C0      		rjmp .L253
  41:TakkI2C.c     **** 	TWIC.MASTER.DATA = 0x01;
 3100               		.loc 1 41 0
 3101 0c54 81E0      		ldi r24,lo8(1)
 3102 0c56 8093 8704 		sts 1159,r24
 3103               	.L254:
  42:TakkI2C.c     **** 	while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3104               		.loc 1 42 0
 3105 0c5a 8091 8404 		lds r24,1156
 3106 0c5e 86FF      		sbrs r24,6
 3107 0c60 00C0      		rjmp .L254
  44:TakkI2C.c     **** 	TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 3108               		.loc 1 44 0
 3109 0c62 8091 8304 		lds r24,1155
 3110 0c66 8360      		ori r24,lo8(3)
 3111 0c68 8093 8304 		sts 1155,r24
  46:TakkI2C.c     **** 	if (ACK == 1) botherAddress(calcTinyAddr(0, 6)^1, 1);
 3112               		.loc 1 46 0
 3113 0c6c C130      		cpi r28,lo8(1)
 3114 0c6e 01F0      		breq .L274
 3115               	.L255:
 3116               	.LBE946:
 3117               	.LBE945:
  18:main.c        **** 
  19:main.c        **** 	// start conversion of next block
  20:main.c        **** 	startConversion();
  21:main.c        **** 
  22:main.c        **** 	// reset timer
  23:main.c        **** 	TCC0.CNT = 0;
 3118               		.loc 8 23 0
 3119 0c70 1092 2008 		sts 2080,__zero_reg__
 3120 0c74 1092 2108 		sts 2080+1,__zero_reg__
 3121               	/* epilogue start */
  24:main.c        **** }
 3122               		.loc 8 24 0
 3123 0c78 FF91      		pop r31
 3124 0c7a EF91      		pop r30
 3125 0c7c DF91      		pop r29
 3126 0c7e CF91      		pop r28
 3127 0c80 BF91      		pop r27
 3128 0c82 AF91      		pop r26
 3129 0c84 9F91      		pop r25
 3130 0c86 8F91      		pop r24
 3131 0c88 7F91      		pop r23
 3132 0c8a 6F91      		pop r22
 3133 0c8c 5F91      		pop r21
 3134 0c8e 4F91      		pop r20
 3135 0c90 3F91      		pop r19
 3136 0c92 2F91      		pop r18
 3137 0c94 0F90      		pop r0
 3138 0c96 0FBE      		out __SREG__,r0
 3139 0c98 0F90      		pop r0
 3140 0c9a 1F90      		pop r1
 3141 0c9c 1895      		reti
 3142               	.L274:
 3143               	.LVL196:
 3144               	.LBB954:
 3145               	.LBB953:
 3146               	.LBB951:
 3147               	.LBB952:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 3148               		.loc 1 17 0
 3149 0c9e 8091 8204 		lds r24,1154
 3150 0ca2 8260      		ori r24,lo8(2)
 3151 0ca4 8093 8204 		sts 1154,r24
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 3152               		.loc 1 19 0
 3153 0ca8 8DE0      		ldi r24,lo8(13)
 3154 0caa 8093 8604 		sts 1158,r24
 3155               	.L256:
  21:TakkI2C.c     **** 	if (address & 1) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 3156               		.loc 1 21 0
 3157 0cae 8091 8404 		lds r24,1156
 3158 0cb2 87FF      		sbrs r24,7
 3159 0cb4 00C0      		rjmp .L256
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 3160               		.loc 1 25 0
 3161 0cb6 8091 8304 		lds r24,1155
 3162 0cba 8360      		ori r24,lo8(3)
 3163 0cbc 8093 8304 		sts 1155,r24
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 3164               		.loc 1 27 0
 3165 0cc0 8091 8404 		lds r24,1156
 3166 0cc4 00C0      		rjmp .L255
 3167               	.LBE952:
 3168               	.LBE951:
 3169               	.LBE953:
 3170               	.LBE954:
 3171               		.cfi_endproc
 3172               	.LFE67:
 3174               		.section	.text.startup,"ax",@progbits
 3175               	.global	main
 3177               	main:
 3178               	.LFB68:
  25:main.c        **** 
  26:main.c        **** int main(void){
 3179               		.loc 8 26 0
 3180               		.cfi_startproc
 3181               	/* prologue: function */
 3182               	/* frame size = 0 */
 3183               	/* stack size = 0 */
 3184               	.L__stack_usage = 0
  27:main.c        **** 	PORTR.DIRSET = 1 << 1;
 3185               		.loc 8 27 0
 3186 0000 82E0      		ldi r24,lo8(2)
 3187 0002 8093 E107 		sts 2017,r24
  28:main.c        **** 	PORTR.OUTSET = 1 << 1;
 3188               		.loc 8 28 0
 3189 0006 8093 E507 		sts 2021,r24
 3190               	.LVL197:
 3191               	.LBB963:
 3192               	.LBB964:
 164:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 3193               		.loc 7 164 0
 3194 000a EFE3      		ldi r30,lo8(-25537)
 3195 000c FCE9      		ldi r31,hi8(-25537)
 3196 000e 3197      		1: sbiw r30,1
 3197 0010 01F4      		brne 1b
 3198 0012 00C0      		rjmp .
 3199 0014 0000      		nop
 3200               	.LBE964:
 3201               	.LBE963:
  29:main.c        **** 	_delay_ms(5);
  30:main.c        **** 	PORTR.OUTCLR = 1 << 1;
 3202               		.loc 8 30 0
 3203 0016 8093 E607 		sts 2022,r24
 3204               	.LVL198:
 3205               	.LBB965:
 3206               	.LBB966:
 164:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 3207               		.loc 7 164 0
 3208 001a FFEF      		ldi r31,lo8(639999)
 3209 001c 23EC      		ldi r18,hi8(639999)
 3210 001e 89E0      		ldi r24,hlo8(639999)
 3211 0020 F150      		1: subi r31,1
 3212 0022 2040      		sbci r18,0
 3213 0024 8040      		sbci r24,0
 3214 0026 01F4      		brne 1b
 3215 0028 00C0      		rjmp .
 3216 002a 0000      		nop
 3217               	.LBE966:
 3218               	.LBE965:
  31:main.c        **** 	_delay_ms(100);
  32:main.c        **** 
  33:main.c        **** 
  34:main.c        **** 	// master-detect
  35:main.c        **** 	PORTE.DIRCLR = 1 << 0;
 3219               		.loc 8 35 0
 3220 002c 81E0      		ldi r24,lo8(1)
 3221 002e 8093 8206 		sts 1666,r24
  36:main.c        **** 	// PE0 is daisy-chaining configuration pin
  37:main.c        **** 	if (PORTE.IN & (1 << 0)) { MASTER = 1; SLAVE = 0; }
 3222               		.loc 8 37 0
 3223 0032 9091 8806 		lds r25,1672
 3224 0036 90FF      		sbrs r25,0
 3225 0038 00C0      		rjmp .L276
 3226               		.loc 8 37 0 is_stmt 0 discriminator 1
 3227 003a 8093 0000 		sts MASTER,r24
 3228 003e 1092 0000 		sts SLAVE,__zero_reg__
 3229               	.L276:
  38:main.c        **** 
  39:main.c        **** 	USB_ConfigureClock();
 3230               		.loc 8 39 0 is_stmt 1
 3231 0042 0E94 0000 		call USB_ConfigureClock
 3232               	.LVL199:
  40:main.c        **** 	USB_Init();
 3233               		.loc 8 40 0
 3234 0046 0E94 0000 		call USB_Init
 3235               	.LVL200:
  41:main.c        **** 		
  42:main.c        **** 	if (MASTER) {
 3236               		.loc 8 42 0
 3237 004a 8091 0000 		lds r24,MASTER
 3238 004e 8823      		tst r24
 3239 0050 01F0      		breq .L277
  43:main.c        **** 		// Enable USB interrupts
  44:main.c        **** 		USB.INTCTRLA = USB_BUSEVIE_bm | USB_INTLVL_MED_gc;
 3240               		.loc 8 44 0
 3241 0052 82E4      		ldi r24,lo8(66)
 3242 0054 8093 C804 		sts 1224,r24
  45:main.c        **** 		USB.INTCTRLB = USB_TRNIE_bm | USB_SETUPIE_bm;
 3243               		.loc 8 45 0
 3244 0058 83E0      		ldi r24,lo8(3)
 3245 005a 8093 C904 		sts 1225,r24
 3246               	.L277:
  46:main.c        **** 	
  47:main.c        **** 	}
  48:main.c        **** 
  49:main.c        **** 	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
 3247               		.loc 8 49 0
 3248 005e 23E0      		ldi r18,lo8(3)
 3249 0060 2093 A200 		sts 162,r18
  50:main.c        **** 	sei(); 
 3250               		.loc 8 50 0
 3251               	/* #APP */
 3252               	 ;  50 "main.c" 1
 3253 0064 7894      		sei
 3254               	 ;  0 "" 2
  51:main.c        **** 
  52:main.c        **** 	// setup TWI bus for master-mode I2C comms
  53:main.c        **** 	TWIC.MASTER.BAUD = TWI_BAUD;
 3255               		.loc 8 53 0
 3256               	/* #NOAPP */
 3257 0066 8BE0      		ldi r24,lo8(11)
 3258 0068 8093 8504 		sts 1157,r24
  54:main.c        **** 	TWIC.MASTER.CTRLA = TWI_MASTER_ENABLE_bm;  
 3259               		.loc 8 54 0
 3260 006c 38E0      		ldi r19,lo8(8)
 3261 006e 3093 8104 		sts 1153,r19
  55:main.c        **** 	TWIC.MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
 3262               		.loc 8 55 0
 3263 0072 81E0      		ldi r24,lo8(1)
 3264 0074 8093 8404 		sts 1156,r24
  56:main.c        **** 
  57:main.c        **** 	// setup TCC0 for sample timing
  58:main.c        **** 	TCC0.CTRLA = TC_CLKSEL_DIV256_gc;
 3265               		.loc 8 58 0
 3266 0078 96E0      		ldi r25,lo8(6)
 3267 007a 9093 0008 		sts 2048,r25
  59:main.c        **** 	TCC0.CTRLB = TC0_CCAEN_bm | TC_WGMODE_SINGLESLOPE_gc;
 3268               		.loc 8 59 0
 3269 007e 93E1      		ldi r25,lo8(19)
 3270 0080 9093 0108 		sts 2049,r25
  60:main.c        **** 	TCC0.INTCTRLB = TC_CCAINTLVL_LO_gc;
 3271               		.loc 8 60 0
 3272 0084 8093 0708 		sts 2055,r24
  61:main.c        **** 	TCC0.CCA = 120; 
 3273               		.loc 8 61 0
 3274 0088 88E7      		ldi r24,lo8(120)
 3275 008a 90E0      		ldi r25,0
 3276 008c 8093 2808 		sts 2088,r24
 3277 0090 9093 2908 		sts 2088+1,r25
  62:main.c        **** 	TCC0.PER = 0;
 3278               		.loc 8 62 0
 3279 0094 1092 2608 		sts 2086,__zero_reg__
 3280 0098 1092 2708 		sts 2086+1,__zero_reg__
  63:main.c        **** 
  64:main.c        **** 	// config PORTE.USARTE0 for serial transmission as 2e6 8 1 n
  65:main.c        **** 	PORTE.DIRSET = 1 << 3;
 3281               		.loc 8 65 0
 3282 009c 3093 8106 		sts 1665,r19
  66:main.c        **** 	PORTE.DIRCLR = 1 << 2;
 3283               		.loc 8 66 0
 3284 00a0 84E0      		ldi r24,lo8(4)
 3285 00a2 8093 8206 		sts 1666,r24
  67:main.c        **** 	USARTE0.BAUDCTRLA = 0;
 3286               		.loc 8 67 0
 3287 00a6 1092 A60A 		sts 2726,__zero_reg__
  68:main.c        **** 	USARTE0.BAUDCTRLB = 0;
 3288               		.loc 8 68 0
 3289 00aa 1092 A70A 		sts 2727,__zero_reg__
  69:main.c        **** 	USARTE0.CTRLC =  USART_PMODE_DISABLED_gc | USART_CHSIZE_8BIT_gc;
 3290               		.loc 8 69 0
 3291 00ae 2093 A50A 		sts 2725,r18
  70:main.c        **** 	if (MASTER) USARTE0.CTRLB |= USART_RXEN_bm;
 3292               		.loc 8 70 0
 3293 00b2 2091 0000 		lds r18,MASTER
 3294 00b6 2223      		tst r18
 3295 00b8 01F0      		breq .L278
 3296               		.loc 8 70 0 is_stmt 0 discriminator 1
 3297 00ba 8091 A40A 		lds r24,2724
 3298 00be 8061      		ori r24,lo8(16)
 3299 00c0 8093 A40A 		sts 2724,r24
 3300               	.L278:
  71:main.c        **** 	if (SLAVE) USARTE0.CTRLB |= USART_TXEN_bm;
 3301               		.loc 8 71 0 is_stmt 1
 3302 00c4 9091 0000 		lds r25,SLAVE
 3303 00c8 9923      		tst r25
 3304 00ca 01F0      		breq .L279
 3305               		.loc 8 71 0 is_stmt 0 discriminator 1
 3306 00cc 8091 A40A 		lds r24,2724
 3307 00d0 8860      		ori r24,lo8(8)
 3308 00d2 8093 A40A 		sts 2724,r24
 3309               	.L279:
  72:main.c        **** 
  73:main.c        **** 	// configure general DMA settings
  74:main.c        **** 	DMA.CTRL = DMA_ENABLE_bm | DMA_DBUFMODE_DISABLED_gc | DMA_PRIMODE_RR0123_gc;
 3310               		.loc 8 74 0 is_stmt 1
 3311 00d6 80E8      		ldi r24,lo8(-128)
 3312 00d8 8093 0001 		sts 256,r24
  75:main.c        **** 
  76:main.c        **** 	if (SLAVE) {
 3313               		.loc 8 76 0
 3314 00dc 9923      		tst r25
 3315 00de 01F0      		breq .L280
  77:main.c        **** 	DMA.CH0.ADDRCTRL = DMA_CH_SRCRELOAD_TRANSACTION_gc | DMA_CH_SRCDIR_INC_gc | DMA_CH_DESTRELOAD_NONE
 3316               		.loc 8 77 0
 3317 00e0 80ED      		ldi r24,lo8(-48)
 3318 00e2 8093 1201 		sts 274,r24
  78:main.c        **** 	DMA.CH0.TRIGSRC = DMA_CH_TRIGSRC_USARTE0_DRE_gc;
 3319               		.loc 8 78 0
 3320 00e6 8CE8      		ldi r24,lo8(-116)
 3321 00e8 8093 1301 		sts 275,r24
  79:main.c        **** 	DMA.CH0.SRCADDR0 = ((uint32_t)(&sensorData) >> (8*0)) & 0xFF;
 3322               		.loc 8 79 0
 3323 00ec 80E0      		ldi r24,lo8(sensorData)
 3324 00ee 90E0      		ldi r25,hi8(sensorData)
 3325 00f0 8093 1801 		sts 280,r24
  80:main.c        **** 	DMA.CH0.SRCADDR1 = ((uint32_t)(&sensorData) >> (8*1)) & 0xFF;
 3326               		.loc 8 80 0
 3327 00f4 AA27      		clr r26
 3328 00f6 97FD      		sbrc r25,7
 3329 00f8 A095      		com r26
 3330 00fa BA2F      		mov r27,r26
 3331 00fc 492F      		mov r20,r25
 3332 00fe 5A2F      		mov r21,r26
 3333 0100 6B2F      		mov r22,r27
 3334 0102 7727      		clr r23
 3335 0104 4093 1901 		sts 281,r20
  81:main.c        **** 	DMA.CH0.SRCADDR2 = ((uint32_t)(&sensorData) >> (8*2)) & 0xFF;
 3336               		.loc 8 81 0
 3337 0108 CD01      		movw r24,r26
 3338 010a AA27      		clr r26
 3339 010c BB27      		clr r27
 3340 010e 8093 1A01 		sts 282,r24
  82:main.c        **** 	DMA.CH0.DESTADDR0 = ((uint32_t)(&USARTE0.DATA) >> (8*0)) & 0xFF;
 3341               		.loc 8 82 0
 3342 0112 80EA      		ldi r24,lo8(-96)
 3343 0114 8093 1C01 		sts 284,r24
  83:main.c        **** 	DMA.CH0.DESTADDR1 = ((uint32_t)(&USARTE0.DATA) >> (8*1)) & 0xFF;
 3344               		.loc 8 83 0
 3345 0118 8AE0      		ldi r24,lo8(10)
 3346 011a 8093 1D01 		sts 285,r24
  84:main.c        **** 	DMA.CH0.DESTADDR2 = ((uint32_t)(&USARTE0.DATA) >> (8*2)) & 0xFF;
 3347               		.loc 8 84 0
 3348 011e 1092 1E01 		sts 286,__zero_reg__
  85:main.c        **** 	DMA.CH0.CTRLA = DMA_CH_ENABLE_bm | DMA_CH_SINGLE_bm | DMA_CH_BURSTLEN_1BYTE_gc; 
 3349               		.loc 8 85 0
 3350 0122 84E8      		ldi r24,lo8(-124)
 3351 0124 8093 1001 		sts 272,r24
 3352               	.L280:
  86:main.c        **** 	}
  87:main.c        **** 	if (MASTER) {
 3353               		.loc 8 87 0
 3354 0128 2223      		tst r18
 3355 012a 01F0      		breq .L281
  88:main.c        **** 	DMA.CH1.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_TRANSACTI
 3356               		.loc 8 88 0
 3357 012c 8DE0      		ldi r24,lo8(13)
 3358 012e 8093 2201 		sts 290,r24
  89:main.c        **** 	DMA.CH1.TRIGSRC = DMA_CH_TRIGSRC_USARTE0_RXC_gc;
 3359               		.loc 8 89 0
 3360 0132 8BE8      		ldi r24,lo8(-117)
 3361 0134 8093 2301 		sts 291,r24
  90:main.c        **** 	DMA.CH1.SRCADDR0 = ((uint32_t)(&USARTE0.DATA) >> (8*0)) & 0xFF;
 3362               		.loc 8 90 0
 3363 0138 80EA      		ldi r24,lo8(-96)
 3364 013a 8093 2801 		sts 296,r24
  91:main.c        **** 	DMA.CH1.SRCADDR1 = ((uint32_t)(&USARTE0.DATA) >> (8*1)) & 0xFF;
 3365               		.loc 8 91 0
 3366 013e 8AE0      		ldi r24,lo8(10)
 3367 0140 8093 2901 		sts 297,r24
  92:main.c        **** 	DMA.CH1.SRCADDR2 = ((uint32_t)(&USARTE0.DATA) >> (8*2)) & 0xFF;
 3368               		.loc 8 92 0
 3369 0144 1092 2A01 		sts 298,__zero_reg__
  93:main.c        **** 	DMA.CH1.DESTADDR0 = ((uint32_t)(&sensorDataPrime) >> (8*0)) & 0xFF;
 3370               		.loc 8 93 0
 3371 0148 80E0      		ldi r24,lo8(sensorDataPrime)
 3372 014a 90E0      		ldi r25,hi8(sensorDataPrime)
 3373 014c 8093 2C01 		sts 300,r24
  94:main.c        **** 	DMA.CH1.DESTADDR1 = ((uint32_t)(&sensorDataPrime) >> (8*1)) & 0xFF;
 3374               		.loc 8 94 0
 3375 0150 AA27      		clr r26
 3376 0152 97FD      		sbrc r25,7
 3377 0154 A095      		com r26
 3378 0156 BA2F      		mov r27,r26
 3379 0158 492F      		mov r20,r25
 3380 015a 5A2F      		mov r21,r26
 3381 015c 6B2F      		mov r22,r27
 3382 015e 7727      		clr r23
 3383 0160 4093 2D01 		sts 301,r20
  95:main.c        **** 	DMA.CH1.DESTADDR2 = ((uint32_t)(&sensorDataPrime) >> (8*2)) & 0xFF;
 3384               		.loc 8 95 0
 3385 0164 CD01      		movw r24,r26
 3386 0166 AA27      		clr r26
 3387 0168 BB27      		clr r27
 3388 016a 8093 2E01 		sts 302,r24
  96:main.c        **** 	DMA.CH1.TRFCNT = 160;
 3389               		.loc 8 96 0
 3390 016e 80EA      		ldi r24,lo8(-96)
 3391 0170 90E0      		ldi r25,0
 3392 0172 8093 2401 		sts 292,r24
 3393 0176 9093 2501 		sts 292+1,r25
  97:main.c        **** 	DMA.CH1.REPCNT = 0;
 3394               		.loc 8 97 0
 3395 017a 1092 2601 		sts 294,__zero_reg__
  98:main.c        **** 	DMA.CH1.CTRLA = DMA_CH_ENABLE_bm | DMA_CH_REPEAT_bm | DMA_CH_SINGLE_bm | DMA_CH_BURSTLEN_1BYTE_gc;
 3396               		.loc 8 98 0
 3397 017e 84EA      		ldi r24,lo8(-92)
 3398 0180 8093 2001 		sts 288,r24
 3399               	.L281:
  99:main.c        **** 	}
 100:main.c        **** 
 101:main.c        **** 	getAliveFlat();
 3400               		.loc 8 101 0
 3401 0184 0E94 0000 		call getAliveFlat
 3402               	.LVL201:
 102:main.c        **** 	//getCalibrationData();
 103:main.c        **** 
 104:main.c        **** 	if (SLAVE && ~MASTER) {
 3403               		.loc 8 104 0
 3404 0188 8091 0000 		lds r24,SLAVE
 3405 018c 8823      		tst r24
 3406 018e 01F0      		breq .L283
 105:main.c        **** 		TCC0.CNT = 0; 
 3407               		.loc 8 105 0 discriminator 1
 3408 0190 1092 2008 		sts 2080,__zero_reg__
 3409 0194 1092 2108 		sts 2080+1,__zero_reg__
 106:main.c        **** 		TCC0.PER = 1 << 15; 
 3410               		.loc 8 106 0 discriminator 1
 3411 0198 80E0      		ldi r24,0
 3412 019a 90E8      		ldi r25,lo8(-128)
 3413 019c 8093 2608 		sts 2086,r24
 3414 01a0 9093 2708 		sts 2086+1,r25
 3415               	.LVL202:
 3416               	.LBB967:
 3417               	.LBB968:
  35:TakkI2C.c     **** 	uint8_t ACK = botherAddress(calcTinyAddr(0, 6), 1);
 3418               		.loc 1 35 0 discriminator 1
 3419 01a4 8CE0      		ldi r24,lo8(12)
 3420 01a6 0E94 0000 		call botherAddress.constprop.8
 3421               	.LVL203:
 3422               	.LBB969:
 3423               	.LBB970:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 3424               		.loc 1 17 0 discriminator 1
 3425 01aa 9091 8204 		lds r25,1154
 3426 01ae 9260      		ori r25,lo8(2)
 3427 01b0 9093 8204 		sts 1154,r25
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 3428               		.loc 1 19 0 discriminator 1
 3429 01b4 90EC      		ldi r25,lo8(-64)
 3430 01b6 9093 8604 		sts 1158,r25
 3431               	.L284:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3432               		.loc 1 23 0
 3433 01ba 9091 8404 		lds r25,1156
 3434 01be 96FF      		sbrs r25,6
 3435 01c0 00C0      		rjmp .L284
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 3436               		.loc 1 27 0
 3437 01c2 9091 8404 		lds r25,1156
 3438               	.LBE970:
 3439               	.LBE969:
  39:TakkI2C.c     **** 	TWIC.MASTER.DATA = 0x12;
 3440               		.loc 1 39 0
 3441 01c6 92E1      		ldi r25,lo8(18)
 3442 01c8 9093 8704 		sts 1159,r25
 3443               	.L285:
  40:TakkI2C.c     **** 	while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3444               		.loc 1 40 0
 3445 01cc 9091 8404 		lds r25,1156
 3446 01d0 96FF      		sbrs r25,6
 3447 01d2 00C0      		rjmp .L285
  41:TakkI2C.c     **** 	TWIC.MASTER.DATA = 0x01;
 3448               		.loc 1 41 0
 3449 01d4 91E0      		ldi r25,lo8(1)
 3450 01d6 9093 8704 		sts 1159,r25
 3451               	.L286:
  42:TakkI2C.c     **** 	while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3452               		.loc 1 42 0
 3453 01da 9091 8404 		lds r25,1156
 3454 01de 96FF      		sbrs r25,6
 3455 01e0 00C0      		rjmp .L286
  44:TakkI2C.c     **** 	TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 3456               		.loc 1 44 0
 3457 01e2 9091 8304 		lds r25,1155
 3458 01e6 9360      		ori r25,lo8(3)
 3459 01e8 9093 8304 		sts 1155,r25
  46:TakkI2C.c     **** 	if (ACK == 1) botherAddress(calcTinyAddr(0, 6)^1, 1);
 3460               		.loc 1 46 0
 3461 01ec 8130      		cpi r24,lo8(1)
 3462 01ee 01F0      		breq .L320
 3463               	.LVL204:
 3464               	.L283:
 3465               	.LBE968:
 3466               	.LBE967:
 107:main.c        **** 		startConversion();
 108:main.c        **** 	}
 109:main.c        **** 
 110:main.c        **** 	PORTR.OUTSET = 1 << 1;
 3467               		.loc 8 110 0
 3468 01f0 82E0      		ldi r24,lo8(2)
 3469 01f2 8093 E507 		sts 2021,r24
 3470               	.L288:
 3471 01f6 00C0      		rjmp .L288
 3472               	.LVL205:
 3473               	.L320:
 3474               	.LBB972:
 3475               	.LBB971:
  46:TakkI2C.c     **** 	if (ACK == 1) botherAddress(calcTinyAddr(0, 6)^1, 1);
 3476               		.loc 1 46 0
 3477 01f8 8DE0      		ldi r24,lo8(13)
 3478               	.LVL206:
 3479 01fa 0E94 0000 		call botherAddress.constprop.8
 3480               	.LVL207:
 3481               	.LBE971:
 3482               	.LBE972:
 3483               		.loc 8 110 0
 3484 01fe 82E0      		ldi r24,lo8(2)
 3485 0200 8093 E507 		sts 2021,r24
 3486 0204 00C0      		rjmp .L288
 3487               		.cfi_endproc
 3488               	.LFE68:
 3490               		.text
 3491               	.global	EVENT_USB_Device_ControlRequest
 3493               	EVENT_USB_Device_ControlRequest:
 3494               	.LFB69:
 111:main.c        **** 	for (;;){
 112:main.c        **** 	}
 113:main.c        **** }
 114:main.c        **** 
 115:main.c        **** 
 116:main.c        **** #define xstringify(s) stringify(s)
 117:main.c        **** #define stringify(s) #s
 118:main.c        **** 
 119:main.c        **** const char PROGMEM hwversion[] = xstringify(HW_VERSION);
 120:main.c        **** const char PROGMEM fwversion[] = xstringify(FW_VERSION);
 121:main.c        **** 
 122:main.c        **** uint8_t usb_cmd = 0;
 123:main.c        **** uint8_t cmd_data = 0;
 124:main.c        **** 
 125:main.c        **** // Add a flag to prevent other i2c-using requests from happening while sampling is enabled. Control
 126:main.c        **** 
 127:main.c        **** /** Event handler for the library USB Control Request reception event. */
 128:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 3495               		.loc 8 128 0
 3496               		.cfi_startproc
 3497               	.LVL208:
 3498 0cc6 CF92      		push r12
 3499               	.LCFI51:
 3500               		.cfi_def_cfa_offset 3
 3501               		.cfi_offset 12, -2
 3502 0cc8 DF92      		push r13
 3503               	.LCFI52:
 3504               		.cfi_def_cfa_offset 4
 3505               		.cfi_offset 13, -3
 3506 0cca EF92      		push r14
 3507               	.LCFI53:
 3508               		.cfi_def_cfa_offset 5
 3509               		.cfi_offset 14, -4
 3510 0ccc FF92      		push r15
 3511               	.LCFI54:
 3512               		.cfi_def_cfa_offset 6
 3513               		.cfi_offset 15, -5
 3514 0cce 0F93      		push r16
 3515               	.LCFI55:
 3516               		.cfi_def_cfa_offset 7
 3517               		.cfi_offset 16, -6
 3518 0cd0 CF93      		push r28
 3519               	.LCFI56:
 3520               		.cfi_def_cfa_offset 8
 3521               		.cfi_offset 28, -7
 3522 0cd2 DF93      		push r29
 3523               	.LCFI57:
 3524               		.cfi_def_cfa_offset 9
 3525               		.cfi_offset 29, -8
 3526               	/* prologue: function */
 3527               	/* frame size = 0 */
 3528               	/* stack size = 7 */
 3529               	.L__stack_usage = 7
 3530 0cd4 7C01      		movw r14,r24
 3531               	.LVL209:
 3532 0cd6 C0E0      		ldi r28,lo8(ep0_buf_in)
 3533 0cd8 D0E0      		ldi r29,hi8(ep0_buf_in)
 3534               		.loc 8 128 0
 3535 0cda 6E01      		movw r12,r28
 3536 0cdc FE01      		movw r30,r28
 3537               	.LVL210:
 3538               	.L322:
 3539               	.LBB1062:
 129:main.c        **** 	// zero out ep0_buf_in
 130:main.c        **** 	for (uint8_t i = 0; i < 64; i++) ep0_buf_in[i] = 0;
 3540               		.loc 8 130 0 discriminator 2
 3541 0cde 1192      		st Z+,__zero_reg__
 3542 0ce0 80E0      		ldi r24,hi8(ep0_buf_in+64)
 3543 0ce2 E030      		cpi r30,lo8(ep0_buf_in+64)
 3544 0ce4 F807      		cpc r31,r24
 3545 0ce6 01F4      		brne .L322
 3546               	.LBE1062:
 131:main.c        **** 	usb_cmd = 0;
 3547               		.loc 8 131 0
 3548 0ce8 1092 0000 		sts usb_cmd,__zero_reg__
 132:main.c        **** 	if ((req->bmRequestType & CONTROL_REQTYPE_TYPE) == REQTYPE_VENDOR){
 3549               		.loc 8 132 0
 3550 0cec D701      		movw r26,r14
 3551 0cee 8C91      		ld r24,X
 3552 0cf0 8076      		andi r24,lo8(96)
 3553 0cf2 8034      		cpi r24,lo8(64)
 3554 0cf4 01F0      		breq .L416
 3555               	.L355:
 133:main.c        **** 		switch(req->bRequest){
 134:main.c        **** 			case 0x00: // Info
 135:main.c        **** 
 136:main.c        **** 				if (req->wIndex == 0){
 137:main.c        **** 					USB_ep0_send_progmem((uint8_t*)hwversion, sizeof(hwversion));
 138:main.c        **** 				}else if (req->wIndex == 1){
 139:main.c        **** 					USB_ep0_send_progmem((uint8_t*)fwversion, sizeof(fwversion));
 140:main.c        **** 				}
 141:main.c        **** 				
 142:main.c        **** 				return true;
 143:main.c        **** 
 144:main.c        **** 			// bother a specified I2C address, return '1' if address ACKs, '0' if NACK
 145:main.c        **** 			// mnemonic - 0xBotherAddress
 146:main.c        **** 			case 0xBA: 
 147:main.c        **** 				ep0_buf_in[0] = botherAddress(req->wIndex, req->wValue);
 148:main.c        **** 				USB_ep0_send(1);
 149:main.c        **** 				return true;
 150:main.c        **** 
 151:main.c        **** 			// start sampling
 152:main.c        **** 			// mnemonic - 0xConfigure7imer
 153:main.c        **** 			case 0xC7:
 154:main.c        **** 				if (req->wIndex != 0) {
 155:main.c        **** 					TCC0.PER = 1 << 15;
 156:main.c        **** 					startConversion();
 157:main.c        **** 					ep0_buf_in[0] = 1;
 158:main.c        **** 					usb_pipe_reset(&ep_in);
 159:main.c        **** 					timeout_or_sampling_no_longer_enabled = 0;
 160:main.c        **** 					TCC0.CCA = req->wValue;
 161:main.c        **** 				}
 162:main.c        **** 				else {
 163:main.c        **** 					TCC0.PER = 0;
 164:main.c        **** 					ep0_buf_in[0] = 0;
 165:main.c        **** 					usb_pipe_reset(&ep_in);
 166:main.c        **** 					timeout_or_sampling_no_longer_enabled = 1;
 167:main.c        **** 				}
 168:main.c        **** 				TCC0.CNT = 0;
 169:main.c        **** 				USB_ep0_send(1);
 170:main.c        **** 				return true;
 171:main.c        **** 
 172:main.c        **** 			// return a bitmap of alive cells 
 173:main.c        **** 			// mnemonic - 0x5Can
 174:main.c        **** 			case 0x5C: 
 175:main.c        **** 				getAliveFlat();
 176:main.c        **** 				_delay_ms(5);
 177:main.c        **** 				for (uint8_t i = 0; i < 40; i++) {ep0_buf_in[i] = aliveCells[i];}
 178:main.c        **** 				USB_ep0_send(40);
 179:main.c        **** 				return true;
 180:main.c        **** 
 181:main.c        **** 			// robust vendor-request based data collection
 182:main.c        **** 			// mnemonic - 0x6etData
 183:main.c        **** 			case 0x6D:
 184:main.c        **** 				if (req->wIndex == 0xFF) {
 185:main.c        **** 					startConversion();
 186:main.c        **** 					_delay_ms(2);
 187:main.c        **** 					USB_ep0_send(0);
 188:main.c        **** 					return true;
 189:main.c        **** 				}
 190:main.c        **** 				if (req->wIndex == 0x0F) {
 191:main.c        **** 					getSensorData();
 192:main.c        **** 					USB_ep0_send(0);
 193:main.c        **** 					return true;
 194:main.c        **** 				}
 195:main.c        **** 				if (req->wIndex == 0x00) { 
 196:main.c        **** 					for (uint8_t i = 0; i < 64; i++) {ep0_buf_in[i] = sensorData[i+(req->wValue*64)];}
 197:main.c        **** 					USB_ep0_send(64);
 198:main.c        **** 					return true;
 199:main.c        **** 				}
 200:main.c        **** 
 201:main.c        **** 			// return calibration information
 202:main.c        **** 			// mnemonic - 0x6etCalibration
 203:main.c        **** 			case 0x6C: {
 204:main.c        **** 				getCalibrationData(req->wIndex&0xFF);
 205:main.c        **** 				USB_ep0_send(8);
 206:main.c        **** 				return true;
 207:main.c        **** 				}
 208:main.c        **** 
 209:main.c        **** 			// disconnect from USB, jump to bootloader	
 210:main.c        **** 			case 0xBB: 
 211:main.c        **** 				USB_enter_bootloader();
 212:main.c        **** 				return true;
 213:main.c        **** 		}
 214:main.c        **** 	}
 215:main.c        **** 	return false;
 3556               		.loc 8 215 0
 3557 0cf6 80E0      		ldi r24,0
 3558               	.L323:
 3559               	/* epilogue start */
 216:main.c        **** }
 3560               		.loc 8 216 0
 3561 0cf8 DF91      		pop r29
 3562 0cfa CF91      		pop r28
 3563 0cfc 0F91      		pop r16
 3564 0cfe FF90      		pop r15
 3565 0d00 EF90      		pop r14
 3566               	.LVL211:
 3567 0d02 DF90      		pop r13
 3568 0d04 CF90      		pop r12
 3569 0d06 0895      		ret
 3570               	.LVL212:
 3571               	.L416:
 133:main.c        **** 		switch(req->bRequest){
 3572               		.loc 8 133 0
 3573 0d08 1196      		adiw r26, 1
 3574 0d0a 8C91      		ld r24,X
 3575 0d0c 8D36      		cpi r24,lo8(109)
 3576 0d0e 01F4      		brne .+2
 3577 0d10 00C0      		rjmp .L327
 3578 0d12 00F4      		brsh .+2
 3579 0d14 00C0      		rjmp .L417
 3580 0d16 8B3B      		cpi r24,lo8(-69)
 3581 0d18 01F4      		brne .+2
 3582 0d1a 00C0      		rjmp .L329
 3583 0d1c 873C      		cpi r24,lo8(-57)
 3584 0d1e 01F4      		brne .+2
 3585 0d20 00C0      		rjmp .L330
 3586 0d22 8A3B      		cpi r24,lo8(-70)
 3587 0d24 01F4      		brne .L355
 147:main.c        **** 				ep0_buf_in[0] = botherAddress(req->wIndex, req->wValue);
 3588               		.loc 8 147 0
 3589 0d26 D701      		movw r26,r14
 3590 0d28 1296      		adiw r26,2
 3591 0d2a 8D91      		ld r24,X+
 3592 0d2c 9C91      		ld r25,X
 3593 0d2e 1397      		sbiw r26,2+1
 3594 0d30 1496      		adiw r26, 4
 3595 0d32 3C91      		ld r19,X
 3596               	.LVL213:
 3597               	.LBB1063:
 3598               	.LBB1064:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 3599               		.loc 1 17 0
 3600 0d34 2091 8204 		lds r18,1154
 3601 0d38 2260      		ori r18,lo8(2)
 3602 0d3a 2093 8204 		sts 1154,r18
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 3603               		.loc 1 19 0
 3604 0d3e 3093 8604 		sts 1158,r19
  21:TakkI2C.c     **** 	if (address & 1) while(!(TWIC.MASTER.STATUS&TWI_MASTER_RIF_bm));
 3605               		.loc 1 21 0
 3606 0d42 30FF      		sbrs r19,0
 3607 0d44 00C0      		rjmp .L385
 3608               	.L384:
 3609 0d46 2091 8404 		lds r18,1156
 3610 0d4a 27FF      		sbrs r18,7
 3611 0d4c 00C0      		rjmp .L384
 3612               	.L335:
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 3613               		.loc 1 25 0
 3614 0d4e 892B      		or r24,r25
 3615 0d50 01F0      		breq .L336
 3616 0d52 8091 8304 		lds r24,1155
 3617               	.LVL214:
 3618 0d56 8360      		ori r24,lo8(3)
 3619 0d58 8093 8304 		sts 1155,r24
 3620               	.L336:
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 3621               		.loc 1 27 0
 3622 0d5c 8091 8404 		lds r24,1156
 3623 0d60 84FB      		bst r24,4
 3624 0d62 6627      		clr r22
 3625 0d64 60F9      		bld r22,0
 3626 0d66 70E0      		ldi r23,0
 3627               	.LBE1064:
 3628 0d68 B1E0      		ldi r27,1
 3629 0d6a 6B27      		eor r22,r27
 3630               	.LBB1065:
 3631 0d6c 6093 0000 		sts ep0_buf_in,r22
 3632               	.LVL215:
 3633               	.L413:
 3634               	.LBE1065:
 3635               	.LBE1063:
 3636               	.LBB1067:
 3637               	.LBB1068:
 3638               	.LBB1069:
 3639               	.LBB1070:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3640               		.loc 6 168 0
 3641 0d70 C092 0000 		sts endpoints+12,r12
 3642 0d74 D092 0000 		sts endpoints+12+1,r13
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3643               		.loc 6 169 0
 3644 0d78 81E0      		ldi r24,lo8(1)
 3645 0d7a 90E0      		ldi r25,0
 3646 0d7c 8093 0000 		sts endpoints+10,r24
 3647 0d80 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3648               		.loc 6 174 0
 3649 0d84 E0E0      		ldi r30,lo8(endpoints+8)
 3650 0d86 F0E0      		ldi r31,hi8(endpoints+8)
 3651               	.LVL216:
 3652               	/* #APP */
 3653               	 ;  174 "usb/usb.h" 1
 3654 0d88 02E2      		ldi r16, 34
 3655 0d8a 0693      		.dc.w 0x9306
 3656               		
 3657               	 ;  0 "" 2
 3658               	/* #NOAPP */
 3659               	.LBE1070:
 3660               	.LBE1069:
 3661               	.LBE1068:
 3662               	.LBE1067:
 170:main.c        **** 				return true;
 3663               		.loc 8 170 0
 3664 0d8c 81E0      		ldi r24,lo8(1)
 3665 0d8e 00C0      		rjmp .L323
 3666               	.LVL217:
 3667               	.L417:
 133:main.c        **** 		switch(req->bRequest){
 3668               		.loc 8 133 0
 3669 0d90 8C35      		cpi r24,lo8(92)
 3670 0d92 01F4      		brne .+2
 3671 0d94 00C0      		rjmp .L325
 3672 0d96 8C36      		cpi r24,lo8(108)
 3673 0d98 01F0      		breq .L326
 3674 0d9a 8111      		cpse r24,__zero_reg__
 3675 0d9c 00C0      		rjmp .L355
 136:main.c        **** 				if (req->wIndex == 0){
 3676               		.loc 8 136 0
 3677 0d9e F701      		movw r30,r14
 3678 0da0 8481      		ldd r24,Z+4
 3679 0da2 9581      		ldd r25,Z+5
 3680 0da4 0097      		sbiw r24,0
 3681 0da6 01F4      		brne .+2
 3682 0da8 00C0      		rjmp .L418
 138:main.c        **** 				}else if (req->wIndex == 1){
 3683               		.loc 8 138 0
 3684 0daa 0197      		sbiw r24,1
 3685 0dac 01F4      		brne .+2
 3686 0dae 00C0      		rjmp .L419
 142:main.c        **** 				return true;
 3687               		.loc 8 142 0
 3688 0db0 81E0      		ldi r24,lo8(1)
 3689 0db2 00C0      		rjmp .L323
 3690               	.LVL218:
 3691               	.L385:
 3692               	.LBB1071:
 3693               	.LBB1066:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3694               		.loc 1 23 0
 3695 0db4 2091 8404 		lds r18,1156
 3696 0db8 26FD      		sbrc r18,6
 3697 0dba 00C0      		rjmp .L335
 3698 0dbc 2091 8404 		lds r18,1156
 3699 0dc0 26FF      		sbrs r18,6
 3700 0dc2 00C0      		rjmp .L385
 3701 0dc4 00C0      		rjmp .L335
 3702               	.LVL219:
 3703               	.L326:
 3704               	.LBE1066:
 3705               	.LBE1071:
 204:main.c        **** 				getCalibrationData(req->wIndex&0xFF);
 3706               		.loc 8 204 0
 3707 0dc6 F701      		movw r30,r14
 3708 0dc8 8481      		ldd r24,Z+4
 3709 0dca 0E94 0000 		call getCalibrationData
 3710               	.LVL220:
 3711               	.LBB1072:
 3712               	.LBB1073:
 3713               	.LBB1074:
 3714               	.LBB1075:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3715               		.loc 6 168 0
 3716 0dce C092 0000 		sts endpoints+12,r12
 3717 0dd2 D092 0000 		sts endpoints+12+1,r13
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3718               		.loc 6 169 0
 3719 0dd6 88E0      		ldi r24,lo8(8)
 3720 0dd8 90E0      		ldi r25,0
 3721 0dda 8093 0000 		sts endpoints+10,r24
 3722 0dde 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3723               		.loc 6 174 0
 3724 0de2 E0E0      		ldi r30,lo8(endpoints+8)
 3725 0de4 F0E0      		ldi r31,hi8(endpoints+8)
 3726               	.LVL221:
 3727               	/* #APP */
 3728               	 ;  174 "usb/usb.h" 1
 3729 0de6 02E2      		ldi r16, 34
 3730 0de8 0693      		.dc.w 0x9306
 3731               		
 3732               	 ;  0 "" 2
 3733               	/* #NOAPP */
 3734               	.LBE1075:
 3735               	.LBE1074:
 3736               	.LBE1073:
 3737               	.LBE1072:
 206:main.c        **** 				return true;
 3738               		.loc 8 206 0
 3739 0dea 81E0      		ldi r24,lo8(1)
 3740 0dec 00C0      		rjmp .L323
 3741               	.LVL222:
 3742               	.L327:
 184:main.c        **** 				if (req->wIndex == 0xFF) {
 3743               		.loc 8 184 0
 3744 0dee D701      		movw r26,r14
 3745 0df0 1496      		adiw r26,4
 3746 0df2 8D91      		ld r24,X+
 3747 0df4 9C91      		ld r25,X
 3748 0df6 1597      		sbiw r26,4+1
 3749 0df8 8F3F      		cpi r24,-1
 3750 0dfa 9105      		cpc r25,__zero_reg__
 3751 0dfc 01F4      		brne .+2
 3752 0dfe 00C0      		rjmp .L420
 190:main.c        **** 				if (req->wIndex == 0x0F) {
 3753               		.loc 8 190 0
 3754 0e00 8F30      		cpi r24,15
 3755 0e02 9105      		cpc r25,__zero_reg__
 3756 0e04 01F4      		brne .+2
 3757 0e06 00C0      		rjmp .L421
 195:main.c        **** 				if (req->wIndex == 0x00) { 
 3758               		.loc 8 195 0
 3759 0e08 892B      		or r24,r25
 3760 0e0a 01F4      		brne .L326
 3761               	.L383:
 3762               	.LBB1076:
 128:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 3763               		.loc 8 128 0 discriminator 2
 3764 0e0c CE01      		movw r24,r28
 3765 0e0e 8050      		subi r24,lo8(ep0_buf_in)
 3766 0e10 9040      		sbci r25,hi8(ep0_buf_in)
 196:main.c        **** 					for (uint8_t i = 0; i < 64; i++) {ep0_buf_in[i] = sensorData[i+(req->wValue*64)];}
 3767               		.loc 8 196 0 discriminator 2
 3768 0e12 D701      		movw r26,r14
 3769 0e14 1296      		adiw r26,2
 3770 0e16 ED91      		ld r30,X+
 3771 0e18 FC91      		ld r31,X
 3772 0e1a 1397      		sbiw r26,2+1
 3773 0e1c 0024      		clr __tmp_reg__
 3774 0e1e F695      		lsr r31
 3775 0e20 E795      		ror r30
 3776 0e22 0794      		ror __tmp_reg__
 3777 0e24 F695      		lsr r31
 3778 0e26 E795      		ror r30
 3779 0e28 0794      		ror __tmp_reg__
 3780 0e2a FE2F      		mov r31,r30
 3781 0e2c E02D      		mov r30,__tmp_reg__
 3782 0e2e E80F      		add r30,r24
 3783 0e30 F91F      		adc r31,r25
 3784 0e32 E050      		subi r30,lo8(-(sensorData))
 3785 0e34 F040      		sbci r31,hi8(-(sensorData))
 3786 0e36 8081      		ld r24,Z
 3787 0e38 8993      		st Y+,r24
 3788               	.LVL223:
 3789 0e3a B0E0      		ldi r27,hi8(ep0_buf_in+64)
 3790 0e3c C030      		cpi r28,lo8(ep0_buf_in+64)
 3791 0e3e DB07      		cpc r29,r27
 3792 0e40 01F4      		brne .L383
 3793               	.LVL224:
 3794               	.LBE1076:
 3795               	.LBB1077:
 3796               	.LBB1078:
 3797               	.LBB1079:
 3798               	.LBB1080:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3799               		.loc 6 168 0
 3800 0e42 C092 0000 		sts endpoints+12,r12
 3801 0e46 D092 0000 		sts endpoints+12+1,r13
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3802               		.loc 6 169 0
 3803 0e4a 80E4      		ldi r24,lo8(64)
 3804 0e4c 90E0      		ldi r25,0
 3805 0e4e 8093 0000 		sts endpoints+10,r24
 3806 0e52 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3807               		.loc 6 174 0
 3808 0e56 E0E0      		ldi r30,lo8(endpoints+8)
 3809 0e58 F0E0      		ldi r31,hi8(endpoints+8)
 3810               	.LVL225:
 3811               	/* #APP */
 3812               	 ;  174 "usb/usb.h" 1
 3813 0e5a 02E2      		ldi r16, 34
 3814 0e5c 0693      		.dc.w 0x9306
 3815               		
 3816               	 ;  0 "" 2
 3817               	/* #NOAPP */
 3818               	.LBE1080:
 3819               	.LBE1079:
 3820               	.LBE1078:
 3821               	.LBE1077:
 198:main.c        **** 					return true;
 3822               		.loc 8 198 0
 3823 0e5e 81E0      		ldi r24,lo8(1)
 3824 0e60 00C0      		rjmp .L323
 3825               	.LVL226:
 3826               	.L325:
 175:main.c        **** 				getAliveFlat();
 3827               		.loc 8 175 0
 3828 0e62 0E94 0000 		call getAliveFlat
 3829               	.LVL227:
 3830               	.LBB1081:
 3831               	.LBB1082:
 164:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 3832               		.loc 7 164 0
 3833 0e66 EFE3      		ldi r30,lo8(-25537)
 3834 0e68 FCE9      		ldi r31,hi8(-25537)
 3835 0e6a 3197      		1: sbiw r30,1
 3836 0e6c 01F4      		brne 1b
 3837 0e6e 00C0      		rjmp .
 3838 0e70 0000      		nop
 3839               	.LVL228:
 3840 0e72 E0E0      		ldi r30,lo8(aliveCells)
 3841 0e74 F0E0      		ldi r31,hi8(aliveCells)
 3842               	.LVL229:
 3843               	.L344:
 3844               	.LBE1082:
 3845               	.LBE1081:
 3846               	.LBB1083:
 177:main.c        **** 				for (uint8_t i = 0; i < 40; i++) {ep0_buf_in[i] = aliveCells[i];}
 3847               		.loc 8 177 0 discriminator 2
 3848 0e76 8191      		ld r24,Z+
 3849 0e78 8993      		st Y+,r24
 3850 0e7a 20E0      		ldi r18,hi8(aliveCells+40)
 3851 0e7c E030      		cpi r30,lo8(aliveCells+40)
 3852 0e7e F207      		cpc r31,r18
 3853 0e80 01F4      		brne .L344
 3854               	.LVL230:
 3855               	.LBE1083:
 3856               	.LBB1084:
 3857               	.LBB1085:
 3858               	.LBB1086:
 3859               	.LBB1087:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3860               		.loc 6 168 0
 3861 0e82 C092 0000 		sts endpoints+12,r12
 3862 0e86 D092 0000 		sts endpoints+12+1,r13
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3863               		.loc 6 169 0
 3864 0e8a 88E2      		ldi r24,lo8(40)
 3865 0e8c 90E0      		ldi r25,0
 3866 0e8e 8093 0000 		sts endpoints+10,r24
 3867 0e92 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3868               		.loc 6 174 0
 3869 0e96 E0E0      		ldi r30,lo8(endpoints+8)
 3870 0e98 F0E0      		ldi r31,hi8(endpoints+8)
 3871               	.LVL231:
 3872               	/* #APP */
 3873               	 ;  174 "usb/usb.h" 1
 3874 0e9a 02E2      		ldi r16, 34
 3875 0e9c 0693      		.dc.w 0x9306
 3876               		
 3877               	 ;  0 "" 2
 3878               	/* #NOAPP */
 3879               	.LBE1087:
 3880               	.LBE1086:
 3881               	.LBE1085:
 3882               	.LBE1084:
 179:main.c        **** 				return true;
 3883               		.loc 8 179 0
 3884 0e9e 81E0      		ldi r24,lo8(1)
 3885 0ea0 00C0      		rjmp .L323
 3886               	.LVL232:
 3887               	.L330:
 154:main.c        **** 				if (req->wIndex != 0) {
 3888               		.loc 8 154 0
 3889 0ea2 F701      		movw r30,r14
 3890 0ea4 8481      		ldd r24,Z+4
 3891 0ea6 9581      		ldd r25,Z+5
 3892 0ea8 892B      		or r24,r25
 3893 0eaa 01F4      		brne .+2
 3894 0eac 00C0      		rjmp .L337
 155:main.c        **** 					TCC0.PER = 1 << 15;
 3895               		.loc 8 155 0
 3896 0eae 80E0      		ldi r24,0
 3897 0eb0 90E8      		ldi r25,lo8(-128)
 3898 0eb2 8093 2608 		sts 2086,r24
 3899 0eb6 9093 2708 		sts 2086+1,r25
 3900               	.LVL233:
 3901               	.LBB1088:
 3902               	.LBB1089:
 3903               	.LBB1090:
 3904               	.LBB1091:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 3905               		.loc 1 17 0
 3906 0eba 8091 8204 		lds r24,1154
 3907 0ebe 8260      		ori r24,lo8(2)
 3908 0ec0 8093 8204 		sts 1154,r24
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 3909               		.loc 1 19 0
 3910 0ec4 8CE0      		ldi r24,lo8(12)
 3911 0ec6 8093 8604 		sts 1158,r24
 3912               	.L338:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3913               		.loc 1 23 0
 3914 0eca 8091 8404 		lds r24,1156
 3915 0ece 86FF      		sbrs r24,6
 3916 0ed0 00C0      		rjmp .L338
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 3917               		.loc 1 25 0
 3918 0ed2 8091 8304 		lds r24,1155
 3919 0ed6 8360      		ori r24,lo8(3)
 3920 0ed8 8093 8304 		sts 1155,r24
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 3921               		.loc 1 27 0
 3922 0edc 8091 8404 		lds r24,1156
 3923 0ee0 84FB      		bst r24,4
 3924 0ee2 4427      		clr r20
 3925 0ee4 40F9      		bld r20,0
 3926 0ee6 50E0      		ldi r21,0
 3927               	.LBE1091:
 3928 0ee8 F1E0      		ldi r31,1
 3929 0eea 4F27      		eor r20,r31
 3930               	.LVL234:
 3931               	.LBE1090:
 3932               	.LBB1092:
 3933               	.LBB1093:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 3934               		.loc 1 17 0
 3935 0eec 8091 8204 		lds r24,1154
 3936 0ef0 8260      		ori r24,lo8(2)
 3937 0ef2 8093 8204 		sts 1154,r24
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 3938               		.loc 1 19 0
 3939 0ef6 80EC      		ldi r24,lo8(-64)
 3940 0ef8 8093 8604 		sts 1158,r24
 3941               	.L339:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3942               		.loc 1 23 0
 3943 0efc 8091 8404 		lds r24,1156
 3944 0f00 86FF      		sbrs r24,6
 3945 0f02 00C0      		rjmp .L339
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 3946               		.loc 1 27 0
 3947 0f04 8091 8404 		lds r24,1156
 3948               	.LBE1093:
 3949               	.LBE1092:
  39:TakkI2C.c     **** 	TWIC.MASTER.DATA = 0x12;
 3950               		.loc 1 39 0
 3951 0f08 82E1      		ldi r24,lo8(18)
 3952 0f0a 8093 8704 		sts 1159,r24
 3953               	.L340:
  40:TakkI2C.c     **** 	while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3954               		.loc 1 40 0
 3955 0f0e 8091 8404 		lds r24,1156
 3956 0f12 86FF      		sbrs r24,6
 3957 0f14 00C0      		rjmp .L340
  41:TakkI2C.c     **** 	TWIC.MASTER.DATA = 0x01;
 3958               		.loc 1 41 0
 3959 0f16 81E0      		ldi r24,lo8(1)
 3960 0f18 8093 8704 		sts 1159,r24
 3961               	.L341:
  42:TakkI2C.c     **** 	while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 3962               		.loc 1 42 0
 3963 0f1c 8091 8404 		lds r24,1156
 3964 0f20 86FF      		sbrs r24,6
 3965 0f22 00C0      		rjmp .L341
  44:TakkI2C.c     **** 	TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 3966               		.loc 1 44 0
 3967 0f24 8091 8304 		lds r24,1155
 3968 0f28 8360      		ori r24,lo8(3)
 3969 0f2a 8093 8304 		sts 1155,r24
  46:TakkI2C.c     **** 	if (ACK == 1) botherAddress(calcTinyAddr(0, 6)^1, 1);
 3970               		.loc 1 46 0
 3971 0f2e 4130      		cpi r20,lo8(1)
 3972 0f30 01F4      		brne .+2
 3973 0f32 00C0      		rjmp .L422
 3974               	.L342:
 3975               	.LBE1089:
 3976               	.LBE1088:
 157:main.c        **** 					ep0_buf_in[0] = 1;
 3977               		.loc 8 157 0
 3978 0f34 81E0      		ldi r24,lo8(1)
 3979 0f36 8093 0000 		sts ep0_buf_in,r24
 3980               	.LVL235:
 3981               	.LBB1095:
 3982               	.LBB1096:
 3983               	.LBB1097:
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3984               		.loc 3 54 0
 3985 0f3a 2FB7      		in r18,__SREG__
 3986               	.LVL236:
 3987               	.LBB1098:
 3988               	.LBB1099:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 3989               		.loc 4 50 0
 3990               	/* #APP */
 3991               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 3992 0f3c F894      		cli
 3993               	 ;  0 "" 2
 3994               	.LVL237:
 3995               	/* #NOAPP */
 3996               	.LBE1099:
 3997               	.LBE1098:
 3998               	.LBB1100:
 3999               	.LBB1101:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 4000               		.loc 5 90 0
 4001 0f3e 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 4002               		.loc 5 91 0
 4003 0f42 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 4004 0f44 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 4005 0f46 8093 0000 		sts ep_in_pipe_data+2,r24
 4006 0f4a 9093 0000 		sts ep_in_pipe_data+2+1,r25
 4007 0f4e 8093 0000 		sts ep_in_pipe_data,r24
 4008 0f52 9093 0000 		sts ep_in_pipe_data+1,r25
 4009               	.LVL238:
 4010               	.LBE1101:
 4011               	.LBE1100:
 4012               	.LBB1102:
 4013               	.LBB1103:
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 4014               		.loc 6 158 0
 4015 0f56 E0E0      		ldi r30,lo8(endpoints+24)
 4016 0f58 F0E0      		ldi r31,hi8(endpoints+24)
 4017               	.LVL239:
 4018               	/* #APP */
 4019               	 ;  158 "usb/usb.h" 1
 4020 0f5a 06E0      		ldi r16, 6
 4021 0f5c 0593      		.dc.w 0x9305
 4022               		
 4023               	 ;  0 "" 2
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 4024               		.loc 6 159 0
 4025               	 ;  159 "usb/usb.h" 1
 4026 0f5e 08E0      		ldi r16, 8
 4027 0f60 0693      		.dc.w 0x9306
 4028               		
 4029               	 ;  0 "" 2
 4030               	/* #NOAPP */
 4031               	.LBE1103:
 4032               	.LBE1102:
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
 4033               		.loc 3 57 0
 4034 0f62 1092 0000 		sts ep_in_data+1,__zero_reg__
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
 4035               		.loc 3 58 0
 4036 0f66 1092 0000 		sts ep_in_data+2,__zero_reg__
 4037 0f6a 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
 4038               		.loc 3 59 0
 4039 0f6e 1092 0000 		sts ep_in_data,__zero_reg__
 4040               	.LVL240:
 4041               	.LBB1104:
 4042               	.LBB1105:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 4043               		.loc 4 70 0
 4044 0f72 2FBF      		out __SREG__,r18
 4045               		.loc 4 71 0
 4046               	.LBE1105:
 4047               	.LBE1104:
 4048               	.LBE1097:
 4049               	.LBE1096:
 4050               	.LBE1095:
 159:main.c        **** 					timeout_or_sampling_no_longer_enabled = 0;
 4051               		.loc 8 159 0
 4052 0f74 1092 0000 		sts timeout_or_sampling_no_longer_enabled,__zero_reg__
 160:main.c        **** 					TCC0.CCA = req->wValue;
 4053               		.loc 8 160 0
 4054 0f78 D701      		movw r26,r14
 4055 0f7a 1296      		adiw r26,2
 4056 0f7c 8D91      		ld r24,X+
 4057 0f7e 9C91      		ld r25,X
 4058 0f80 1397      		sbiw r26,2+1
 4059 0f82 8093 2808 		sts 2088,r24
 4060 0f86 9093 2908 		sts 2088+1,r25
 4061 0f8a 00C0      		rjmp .L343
 4062               	.LVL241:
 4063               	.L329:
 4064               	.LBB1106:
 4065               	.LBB1107:
 330:usb/usb.h     **** 		USB_ep0_enableOut();
 331:usb/usb.h     **** 	}
 332:usb/usb.h     **** }
 333:usb/usb.h     **** 
 334:usb/usb.h     **** static inline void USB_enter_bootloader(void){
 335:usb/usb.h     **** 	cli();
 4066               		.loc 6 335 0
 4067               	/* #APP */
 4068               	 ;  335 "usb/usb.h" 1
 4069 0f8c F894      		cli
 4070               	 ;  0 "" 2
 4071               	.LVL242:
 4072               	/* #NOAPP */
 4073               	.LBB1108:
 4074               	.LBB1109:
 4075               	.LBB1110:
 4076               	.LBB1111:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 4077               		.loc 6 168 0
 4078 0f8e C092 0000 		sts endpoints+12,r12
 4079 0f92 D092 0000 		sts endpoints+12+1,r13
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 4080               		.loc 6 169 0
 4081 0f96 1092 0000 		sts endpoints+10,__zero_reg__
 4082 0f9a 1092 0000 		sts endpoints+10+1,__zero_reg__
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 4083               		.loc 6 174 0
 4084 0f9e E0E0      		ldi r30,lo8(endpoints+8)
 4085 0fa0 F0E0      		ldi r31,hi8(endpoints+8)
 4086               	.LVL243:
 4087               	/* #APP */
 4088               	 ;  174 "usb/usb.h" 1
 4089 0fa2 02E2      		ldi r16, 34
 4090 0fa4 0693      		.dc.w 0x9306
 4091               		
 4092               	 ;  0 "" 2
 4093               	/* #NOAPP */
 4094               	.LBE1111:
 4095               	.LBE1110:
 4096               	.LBE1109:
 4097               	.LBE1108:
 4098               	.LBB1112:
 4099               	.LBB1113:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 4100               		.loc 6 280 0
 4101 0fa6 E0E0      		ldi r30,lo8(endpoints)
 4102 0fa8 F0E0      		ldi r31,hi8(endpoints)
 4103               	.LVL244:
 4104               	/* #APP */
 4105               	 ;  280 "usb/usb.h" 1
 4106 0faa 02E7      		ldi r16, 114
 4107 0fac 0693      		.dc.w 0x9306
 4108               		
 4109               	 ;  0 "" 2
 4110               	.LVL245:
 4111               	/* #NOAPP */
 4112               	.L353:
 4113               	.LBE1113:
 4114               	.LBE1112:
 4115               	.LBB1114:
 4116               	.LBB1115:
 4117               	.LBB1116:
 4118               	.LBB1117:
 202:usb/usb.h     **** 		return e->STATUS & USB_EP_TRNCOMPL0_bm;
 4119               		.loc 6 202 0
 4120 0fae 8091 0000 		lds r24,endpoints
 4121               	.LBE1117:
 4122               	.LBE1116:
 253:usb/usb.h     **** 	while (!USB_ep_done(ep)){};
 4123               		.loc 6 253 0
 4124 0fb2 85FF      		sbrs r24,5
 4125 0fb4 00C0      		rjmp .L353
 4126               	.LVL246:
 4127               	.LBE1115:
 4128               	.LBE1114:
 4129               	.LBB1118:
 4130               	.LBB1119:
 164:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 4131               		.loc 7 164 0
 4132 0fb6 FFEF      		ldi r31,lo8(63999)
 4133 0fb8 29EF      		ldi r18,hi8(63999)
 4134 0fba 80E0      		ldi r24,hlo8(63999)
 4135 0fbc F150      		1: subi r31,1
 4136 0fbe 2040      		sbci r18,0
 4137 0fc0 8040      		sbci r24,0
 4138 0fc2 01F4      		brne 1b
 4139 0fc4 00C0      		rjmp .
 4140 0fc6 0000      		nop
 4141               	.LBE1119:
 4142               	.LBE1118:
 4143               	.LBB1120:
 4144               	.LBB1121:
 296:usb/usb.h     **** 	USB.CTRLB &= ~USB_ATTACH_bm;
 4145               		.loc 6 296 0
 4146 0fc8 8091 C104 		lds r24,1217
 4147 0fcc 8E7F      		andi r24,lo8(-2)
 4148 0fce 8093 C104 		sts 1217,r24
 4149               	.LVL247:
 4150               	.LBE1121:
 4151               	.LBE1120:
 4152               	.LBB1122:
 4153               	.LBB1123:
 164:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 4154               		.loc 7 164 0
 4155 0fd2 9FEF      		ldi r25,lo8(639999)
 4156 0fd4 A3EC      		ldi r26,hi8(639999)
 4157 0fd6 B9E0      		ldi r27,hlo8(639999)
 4158 0fd8 9150      		1: subi r25,1
 4159 0fda A040      		sbci r26,0
 4160 0fdc B040      		sbci r27,0
 4161 0fde 01F4      		brne 1b
 4162 0fe0 00C0      		rjmp .
 4163 0fe2 0000      		nop
 4164               	.LVL248:
 4165               	.LBE1123:
 4166               	.LBE1122:
 336:usb/usb.h     **** 	USB_ep0_send(0);
 337:usb/usb.h     **** 	USB_ep0_enableOut();
 338:usb/usb.h     **** 	USB_ep_wait(0x00); // Wait for the status stage to complete
 339:usb/usb.h     **** 	_delay_ms(10);
 340:usb/usb.h     **** 	USB_Detach();
 341:usb/usb.h     **** 	_delay_ms(100);
 342:usb/usb.h     **** 	void (*enter_bootloader)(void) = (void*) 0x47fc /*0x8ff8/2*/;
 343:usb/usb.h     **** 	enter_bootloader();
 4167               		.loc 6 343 0
 4168 0fe4 ECEF      		ldi r30,lo8(-4)
 4169 0fe6 F7E4      		ldi r31,lo8(71)
 4170 0fe8 0995      		icall
 4171               	.LVL249:
 212:main.c        **** 				return true;
 4172               		.loc 8 212 0
 4173 0fea 81E0      		ldi r24,lo8(1)
 4174 0fec 00C0      		rjmp .L323
 4175               	.LVL250:
 4176               	.L337:
 4177               	.LBE1107:
 4178               	.LBE1106:
 163:main.c        **** 					TCC0.PER = 0;
 4179               		.loc 8 163 0
 4180 0fee 1092 2608 		sts 2086,__zero_reg__
 4181 0ff2 1092 2708 		sts 2086+1,__zero_reg__
 164:main.c        **** 					ep0_buf_in[0] = 0;
 4182               		.loc 8 164 0
 4183 0ff6 1092 0000 		sts ep0_buf_in,__zero_reg__
 4184               	.LVL251:
 4185               	.LBB1124:
 4186               	.LBB1125:
 4187               	.LBB1126:
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 4188               		.loc 3 54 0
 4189 0ffa 2FB7      		in r18,__SREG__
 4190               	.LVL252:
 4191               	.LBB1127:
 4192               	.LBB1128:
  50:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     cli();
 4193               		.loc 4 50 0
 4194               	/* #APP */
 4195               	 ;  50 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/ut
 4196 0ffc F894      		cli
 4197               	 ;  0 "" 2
 4198               	.LVL253:
 4199               	/* #NOAPP */
 4200               	.LBE1128:
 4201               	.LBE1127:
 4202               	.LBB1129:
 4203               	.LBB1130:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 4204               		.loc 5 90 0
 4205 0ffe 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 4206               		.loc 5 91 0
 4207 1002 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 4208 1004 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 4209 1006 8093 0000 		sts ep_in_pipe_data+2,r24
 4210 100a 9093 0000 		sts ep_in_pipe_data+2+1,r25
 4211 100e 8093 0000 		sts ep_in_pipe_data,r24
 4212 1012 9093 0000 		sts ep_in_pipe_data+1,r25
 4213               	.LVL254:
 4214               	.LBE1130:
 4215               	.LBE1129:
 4216               	.LBB1131:
 4217               	.LBB1132:
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 4218               		.loc 6 158 0
 4219 1016 E0E0      		ldi r30,lo8(endpoints+24)
 4220 1018 F0E0      		ldi r31,hi8(endpoints+24)
 4221               	.LVL255:
 4222               	/* #APP */
 4223               	 ;  158 "usb/usb.h" 1
 4224 101a 06E0      		ldi r16, 6
 4225 101c 0593      		.dc.w 0x9305
 4226               		
 4227               	 ;  0 "" 2
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 4228               		.loc 6 159 0
 4229               	 ;  159 "usb/usb.h" 1
 4230 101e 08E0      		ldi r16, 8
 4231 1020 0693      		.dc.w 0x9306
 4232               		
 4233               	 ;  0 "" 2
 4234               	/* #NOAPP */
 4235               	.LBE1132:
 4236               	.LBE1131:
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
 4237               		.loc 3 57 0
 4238 1022 1092 0000 		sts ep_in_data+1,__zero_reg__
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
 4239               		.loc 3 58 0
 4240 1026 1092 0000 		sts ep_in_data+2,__zero_reg__
 4241 102a 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
 4242               		.loc 3 59 0
 4243 102e 1092 0000 		sts ep_in_data,__zero_reg__
 4244               	.LVL256:
 4245               	.LBB1133:
 4246               	.LBB1134:
  70:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 4247               		.loc 4 70 0
 4248 1032 2FBF      		out __SREG__,r18
 4249               		.loc 4 71 0
 4250               	.LBE1134:
 4251               	.LBE1133:
 4252               	.LBE1126:
 4253               	.LBE1125:
 4254               	.LBE1124:
 166:main.c        **** 					timeout_or_sampling_no_longer_enabled = 1;
 4255               		.loc 8 166 0
 4256 1034 81E0      		ldi r24,lo8(1)
 4257 1036 8093 0000 		sts timeout_or_sampling_no_longer_enabled,r24
 4258               	.LVL257:
 4259               	.L343:
 168:main.c        **** 				TCC0.CNT = 0;
 4260               		.loc 8 168 0
 4261 103a 1092 2008 		sts 2080,__zero_reg__
 4262 103e 1092 2108 		sts 2080+1,__zero_reg__
 4263 1042 00C0      		rjmp .L413
 4264               	.LVL258:
 4265               	.L418:
 137:main.c        **** 					USB_ep0_send_progmem((uint8_t*)hwversion, sizeof(hwversion));
 4266               		.loc 8 137 0
 4267 1044 64E0      		ldi r22,lo8(4)
 4268 1046 70E0      		ldi r23,0
 4269 1048 80E0      		ldi r24,lo8(hwversion)
 4270 104a 90E0      		ldi r25,hi8(hwversion)
 4271 104c 0E94 0000 		call USB_ep0_send_progmem
 4272               	.LVL259:
 142:main.c        **** 				return true;
 4273               		.loc 8 142 0
 4274 1050 81E0      		ldi r24,lo8(1)
 4275 1052 00C0      		rjmp .L323
 4276               	.L420:
 4277               	.LVL260:
 4278               	.LBB1135:
 4279               	.LBB1136:
 4280               	.LBB1137:
 4281               	.LBB1138:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 4282               		.loc 1 17 0
 4283 1054 8091 8204 		lds r24,1154
 4284 1058 8260      		ori r24,lo8(2)
 4285 105a 8093 8204 		sts 1154,r24
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 4286               		.loc 1 19 0
 4287 105e 8CE0      		ldi r24,lo8(12)
 4288 1060 8093 8604 		sts 1158,r24
 4289               	.L346:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 4290               		.loc 1 23 0
 4291 1064 8091 8404 		lds r24,1156
 4292 1068 86FF      		sbrs r24,6
 4293 106a 00C0      		rjmp .L346
  25:TakkI2C.c     **** 	if (stop) TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 4294               		.loc 1 25 0
 4295 106c 8091 8304 		lds r24,1155
 4296 1070 8360      		ori r24,lo8(3)
 4297 1072 8093 8304 		sts 1155,r24
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 4298               		.loc 1 27 0
 4299 1076 8091 8404 		lds r24,1156
 4300 107a 84FB      		bst r24,4
 4301 107c 2227      		clr r18
 4302 107e 20F9      		bld r18,0
 4303 1080 30E0      		ldi r19,0
 4304               	.LBE1138:
 4305 1082 B1E0      		ldi r27,1
 4306 1084 2B27      		eor r18,r27
 4307               	.LVL261:
 4308               	.LBE1137:
 4309               	.LBB1139:
 4310               	.LBB1140:
  17:TakkI2C.c     **** 	TWIC.MASTER.CTRLB |= TWI_MASTER_QCEN_bm;
 4311               		.loc 1 17 0
 4312 1086 8091 8204 		lds r24,1154
 4313 108a 8260      		ori r24,lo8(2)
 4314 108c 8093 8204 		sts 1154,r24
  19:TakkI2C.c     **** 	TWIC.MASTER.ADDR = address;
 4315               		.loc 1 19 0
 4316 1090 80EC      		ldi r24,lo8(-64)
 4317 1092 8093 8604 		sts 1158,r24
 4318               	.L347:
  23:TakkI2C.c     **** 	else while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 4319               		.loc 1 23 0
 4320 1096 8091 8404 		lds r24,1156
 4321 109a 86FF      		sbrs r24,6
 4322 109c 00C0      		rjmp .L347
  27:TakkI2C.c     **** 	return ((TWIC.MASTER.STATUS & TWI_MASTER_RXACK_bm) >> 4)^1; 
 4323               		.loc 1 27 0
 4324 109e 8091 8404 		lds r24,1156
 4325               	.LBE1140:
 4326               	.LBE1139:
  39:TakkI2C.c     **** 	TWIC.MASTER.DATA = 0x12;
 4327               		.loc 1 39 0
 4328 10a2 82E1      		ldi r24,lo8(18)
 4329 10a4 8093 8704 		sts 1159,r24
 4330               	.L348:
  40:TakkI2C.c     **** 	while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 4331               		.loc 1 40 0
 4332 10a8 8091 8404 		lds r24,1156
 4333 10ac 86FF      		sbrs r24,6
 4334 10ae 00C0      		rjmp .L348
  41:TakkI2C.c     **** 	TWIC.MASTER.DATA = 0x01;
 4335               		.loc 1 41 0
 4336 10b0 81E0      		ldi r24,lo8(1)
 4337 10b2 8093 8704 		sts 1159,r24
 4338               	.L349:
  42:TakkI2C.c     **** 	while(!(TWIC.MASTER.STATUS&TWI_MASTER_WIF_bm));
 4339               		.loc 1 42 0
 4340 10b6 8091 8404 		lds r24,1156
 4341 10ba 86FF      		sbrs r24,6
 4342 10bc 00C0      		rjmp .L349
  44:TakkI2C.c     **** 	TWIC.MASTER.CTRLC |= TWI_MASTER_CMD_STOP_gc;
 4343               		.loc 1 44 0
 4344 10be 8091 8304 		lds r24,1155
 4345 10c2 8360      		ori r24,lo8(3)
 4346 10c4 8093 8304 		sts 1155,r24
  46:TakkI2C.c     **** 	if (ACK == 1) botherAddress(calcTinyAddr(0, 6)^1, 1);
 4347               		.loc 1 46 0
 4348 10c8 2130      		cpi r18,lo8(1)
 4349 10ca 01F0      		breq .L423
 4350               	.L350:
 4351               	.LVL262:
 4352               	.LBE1136:
 4353               	.LBE1135:
 4354               	.LBB1142:
 4355               	.LBB1143:
 164:/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 4356               		.loc 7 164 0
 4357 10cc EFE7      		ldi r30,lo8(15999)
 4358 10ce FEE3      		ldi r31,hi8(15999)
 4359 10d0 3197      		1: sbiw r30,1
 4360 10d2 01F4      		brne 1b
 4361 10d4 00C0      		rjmp .
 4362 10d6 0000      		nop
 4363               	.LVL263:
 4364               	.L414:
 4365               	.LBE1143:
 4366               	.LBE1142:
 4367               	.LBB1144:
 4368               	.LBB1145:
 4369               	.LBB1146:
 4370               	.LBB1147:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 4371               		.loc 6 168 0
 4372 10d8 C092 0000 		sts endpoints+12,r12
 4373 10dc D092 0000 		sts endpoints+12+1,r13
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 4374               		.loc 6 169 0
 4375 10e0 1092 0000 		sts endpoints+10,__zero_reg__
 4376 10e4 1092 0000 		sts endpoints+10+1,__zero_reg__
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 4377               		.loc 6 174 0
 4378 10e8 E0E0      		ldi r30,lo8(endpoints+8)
 4379 10ea F0E0      		ldi r31,hi8(endpoints+8)
 4380               	.LVL264:
 4381               	/* #APP */
 4382               	 ;  174 "usb/usb.h" 1
 4383 10ec 02E2      		ldi r16, 34
 4384 10ee 0693      		.dc.w 0x9306
 4385               		
 4386               	 ;  0 "" 2
 4387               	/* #NOAPP */
 4388               	.LBE1147:
 4389               	.LBE1146:
 4390               	.LBE1145:
 4391               	.LBE1144:
 193:main.c        **** 					return true;
 4392               		.loc 8 193 0
 4393 10f0 81E0      		ldi r24,lo8(1)
 4394 10f2 00C0      		rjmp .L323
 4395               	.LVL265:
 4396               	.L419:
 139:main.c        **** 					USB_ep0_send_progmem((uint8_t*)fwversion, sizeof(fwversion));
 4397               		.loc 8 139 0
 4398 10f4 68E0      		ldi r22,lo8(8)
 4399 10f6 70E0      		ldi r23,0
 4400 10f8 80E0      		ldi r24,lo8(fwversion)
 4401 10fa 90E0      		ldi r25,hi8(fwversion)
 4402 10fc 0E94 0000 		call USB_ep0_send_progmem
 4403               	.LVL266:
 142:main.c        **** 				return true;
 4404               		.loc 8 142 0
 4405 1100 81E0      		ldi r24,lo8(1)
 4406 1102 00C0      		rjmp .L323
 4407               	.L421:
 191:main.c        **** 					getSensorData();
 4408               		.loc 8 191 0
 4409 1104 0E94 0000 		call getSensorData
 4410               	.LVL267:
 4411 1108 00C0      		rjmp .L414
 4412               	.LVL268:
 4413               	.L423:
 4414               	.LBB1148:
 4415               	.LBB1141:
  46:TakkI2C.c     **** 	if (ACK == 1) botherAddress(calcTinyAddr(0, 6)^1, 1);
 4416               		.loc 1 46 0
 4417 110a 8DE0      		ldi r24,lo8(13)
 4418 110c 0E94 0000 		call botherAddress.constprop.8
 4419               	.LVL269:
 4420 1110 00C0      		rjmp .L350
 4421               	.LVL270:
 4422               	.L422:
 4423               	.LBE1141:
 4424               	.LBE1148:
 4425               	.LBB1149:
 4426               	.LBB1094:
 4427 1112 8DE0      		ldi r24,lo8(13)
 4428 1114 0E94 0000 		call botherAddress.constprop.8
 4429               	.LVL271:
 4430 1118 00C0      		rjmp .L342
 4431               	.LBE1094:
 4432               	.LBE1149:
 4433               		.cfi_endproc
 4434               	.LFE69:
 4436               	.global	cmd_data
 4437               		.section .bss
 4440               	cmd_data:
 4441 0000 00        		.zero	1
 4442               	.global	usb_cmd
 4445               	usb_cmd:
 4446 0001 00        		.zero	1
 4447               	.global	fwversion
 4448               		.section	.progmem.data,"a",@progbits
 4451               	fwversion:
 4452 0000 3561 6634 		.string	"5af4227"
 4452      3232 3700 
 4453               	.global	hwversion
 4456               	hwversion:
 4457 0008 312E 3000 		.string	"1.0"
 4458               		.comm	sensorDataPrime,512,1
 4459               		.comm	sensorData,512,1
 4460               		.comm	aliveCells,40,1
 4461               	.global	ep_in_data
 4462               		.section .bss
 4465               	ep_in_data:
 4466 0002 0000 0000 		.zero	4
 4467               	.global	ep_in_pipe_data
 4468               		.data
 4471               	ep_in_pipe_data:
 4472 0000 0000      		.word	ep_in_pipe_buffer
 4473 0002 0000      		.word	ep_in_pipe_buffer
 4474 0004 00        		.byte	0
 4475               		.comm	ep_in_pipe_buffer,512,1
 4476               	.global	timeout_or_sampling_no_longer_enabled
 4479               	timeout_or_sampling_no_longer_enabled:
 4480 0005 01        		.byte	1
 4481               	.global	MASTER
 4482               		.section .bss
 4485               	MASTER:
 4486 0006 00        		.zero	1
 4487               	.global	SLAVE
 4488               		.data
 4491               	SLAVE:
 4492 0006 01        		.byte	1
 4493               		.text
 4494               	.Letext0:
 4495               		.file 9 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/
 4496               		.file 10 "/usr/local/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.7.2/../../../../avr/include
 4497               		.file 11 "usb/StdRequestType.h"
 4498               		.file 12 "usb/Events.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cchaSNgD.s:2      *ABS*:0000003e __SP_H__
     /tmp/cchaSNgD.s:3      *ABS*:0000003d __SP_L__
     /tmp/cchaSNgD.s:4      *ABS*:0000003f __SREG__
     /tmp/cchaSNgD.s:5      *ABS*:00000034 __CCP__
     /tmp/cchaSNgD.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cchaSNgD.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cchaSNgD.s:12     .text:00000000 botherAddress.constprop.8
     /tmp/cchaSNgD.s:66     .text:0000004a EVENT_USB_Device_ConfigurationChanged
     /tmp/cchaSNgD.s:4471   .data:00000000 ep_in_pipe_data
                            *COM*:00000200 ep_in_pipe_buffer
     /tmp/cchaSNgD.s:4465   .bss:00000002 ep_in_data
     /tmp/cchaSNgD.s:153    .text:00000090 __vector_125
     /tmp/cchaSNgD.s:290    .text:00000120 __vector_126
     /tmp/cchaSNgD.s:757    .text:000002e2 botherAddress
     /tmp/cchaSNgD.s:816    .text:00000330 getCalibrationData
                            *COM*:00000028 aliveCells
     /tmp/cchaSNgD.s:1015   .text:00000454 getSensorData
                            *COM*:00000200 sensorData
     /tmp/cchaSNgD.s:4479   .data:00000005 timeout_or_sampling_no_longer_enabled
     /tmp/cchaSNgD.s:4485   .bss:00000006 MASTER
                            *COM*:00000200 sensorDataPrime
     /tmp/cchaSNgD.s:4491   .data:00000006 SLAVE
     /tmp/cchaSNgD.s:2748   .text:00000aee getAliveFlat
     /tmp/cchaSNgD.s:2963   .text:00000bcc __vector_16
     /tmp/cchaSNgD.s:3177   .text.startup:00000000 main
     /tmp/cchaSNgD.s:3493   .text:00000cc6 EVENT_USB_Device_ControlRequest
     /tmp/cchaSNgD.s:4445   .bss:00000001 usb_cmd
     /tmp/cchaSNgD.s:4456   .progmem.data:00000008 hwversion
     /tmp/cchaSNgD.s:4451   .progmem.data:00000000 fwversion
     /tmp/cchaSNgD.s:4440   .bss:00000000 cmd_data

UNDEFINED SYMBOLS
endpoints
USB_Init
USB_HandleSetup
ep0_buf_out
EVENT_USB_Device_ControlOUT
ep0_buf_in
USB_ConfigureClock
USB_ep0_send_progmem
__do_copy_data
__do_clear_bss
